from gsapy.util import GSAError
from gsapy.util import strip_quotes as sq
from gsapy.enum import *
from functools import reduce
from collections import deque, namedtuple
import re


########################################################################################################################
# Functions for casting to / from gwa syntax
# All functions work on deques FROM gwa syntax to attributes
########################################################################################################################

def _str_to_intstr(gwa):
    r = gwa.popleft()
    try:
        return int(r)
    except ValueError:
        return r


def _bool_yes(b):
    if isinstance(b, bool):
        return 'YES' if b else 'NO'
    elif b.upper() == 'YES':
        return True
    elif b.upper() == 'NO':
        return False
    else:
        raise GSAError('Invalid cast between "yes"/"no" and boolean')


def is_float(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


_int_func = (lambda gwa: int(gwa.popleft()), lambda x: str(x))
_str_func = (lambda gwa: sq(gwa.popleft()), lambda x: x)
_str_strip_func = (lambda gwa: gwa.popleft().strip(), lambda x: x)
_bool_yes_func = (lambda gwa: _bool_yes(gwa.popleft()), lambda x: _bool_yes(x))
_float_1_func = (lambda gwa: float(gwa.popleft()), lambda x: str(x))
_float_2_func = (lambda gwa: [float(y) for y in [gwa.popleft(), gwa.popleft()]],
                 lambda x: '\t'.join([str(y) for y in x]))
_intstr_func = (lambda gwa: _str_to_intstr(gwa), lambda x: str(x))

# GWA attribute to raw attribute function map
_raw_attr_func = {
    'axis': _int_func,  # Global axis
    'beam_axis': _intstr_func,  # Beam axis
    'case': _int_func,
    'edge': _int_func,
    'list': _str_strip_func,
    'name': _str_func,
    'num': _int_func,
    'node_axis': _intstr_func,
    'proj': _bool_yes_func,
    'pos': _str_func,
    'pos_1': _str_func,
    'pos_2': _str_func,
    'value': _float_1_func,
    'value_1': _float_1_func,
    'value_2': _float_1_func,
    'value(2)': _float_2_func,
    'dir': _str_func
}


def _parse_record_sID(record_sID):
    if ':' in record_sID:
        return record_sID[:record_sID.index(':')], record_sID[record_sID.index(':') + 1:]
    else:
        return record_sID, None


def _write_sID(sID):
    if sID:
        return ':' + sID
    else:
        return ''


def _from_gwa(module_cls, gwa):
    '''
    Automated parsing of gwa syntax.
    :param module_cls: module class (Node, BeamLoad etc.) that should be instantiated by this gwa record.
    module_cls.syntax defines the syntax format.
    module_cls._attr defines the class's attributes, which may differ from the gwa syntax attributes if some class
    attributes combine one or more syntax attributes. As an example, class Node.coords combines GWA NODE.2 X, Y, Z
    attributes.
    module_cls._syntax_attr_rename defines attributes that are renamed, typically where they would cause confusion
    with python's in-built types.
    See _Module class for more information
    :param gwa: gwa record
    :return: an instance of module_cls instantiated with attributes derived from the gwa record.
    '''
    # TODO This does not parse syntax with optional parameters. These need to be written on a case-by-case basis
    if '{' in module_cls._syntax:
        raise GSAError('The default from_gwa function cannot handle syntax with optional parameters')
    syntax_attr = re.sub(r'\s+', '', module_cls._syntax).split('|')
    tokens = deque(gwa)
    module_name, sID = _parse_record_sID(tokens.popleft())
    raw_attr_proc = []
    # Default to string if no gwa attr -> raw attr function exists
    # ADDED to delete...
    # print('tokens: ', tokens)
    # print('syntax_attr[1:]: ', syntax_attr[1:])
    for attr in syntax_attr[1:]:
        if attr in _raw_attr_func:
            if tokens[0] in ['GLOBAL', 'LOCAL']:
                raw_attr_proc.append(_str_func[0](tokens))
            else:
                raw_attr_proc.append(_raw_attr_func[attr][0](tokens))
        else:
            raw_attr_proc.append(_str_func[0](tokens))
    # Dict of all gsapy class attributes as key, and the processed version as value
    # (ie. 'num' : int(num))
    raw_attr = dict(zip(syntax_attr[1:], raw_attr_proc))
    if tokens:
        raise GSAError('Attributes remain after processing.')

    # ADDED to delete...
    # print('raw_attr:', raw_attr)

    # Initialise set of default attributes
    attr_defaults = {}
    # Initialise list of all gsapy attributes for the class
    attr_to_process = list(module_cls._attr)
    # Order of precedence for assigning attributes is:
    # Processed attributes, which are dependent on prior attributes
    # Renamed attributes, and
    # The attributes of the gwa syntax itself
    # Expanded syntax process list
    syntax_process_exp = []
    # Expanding attributes that require further processing from raw
    # gwa to gsapy attributes
    for x in module_cls._syntax_process:
        syntax_process_exp += list(x)
    # Loop through list of all gsapy attributes for the class...
    while attr_to_process:
        # If the first item in list of all gsapy attributes is in list of attributes
        # that require further processing...
        if attr_to_process[0] in syntax_process_exp:
            # For each attribute in module_cls that needs further processing...
            for process_attr in module_cls._syntax_process:
                # If the first item in list of all gsapy attributes is in list of
                # current batch of module_cls attributes to be processed...
                if attr_to_process[0] in process_attr:
                    # If there is only one attribute, it is the output value, otherwise zip attributes against values
                    if len(process_attr) > 1:
                        attr_defaults.update(zip(process_attr, module_cls._syntax_process[process_attr](raw_attr)))
                    else:
                        attr_defaults.update({process_attr[0]: module_cls._syntax_process[process_attr](raw_attr)})
                    for attr in process_attr:
                        attr_to_process.remove(attr)
                    break
        elif attr_to_process[0] in module_cls._syntax_attr_rename:
            attr_defaults.update({attr_to_process[0]: raw_attr[module_cls._syntax_attr_rename[attr_to_process[0]]]})
            attr_to_process.pop(0)
        else:
            attr_defaults.update({attr_to_process[0]: raw_attr[attr_to_process[0]]})
            attr_to_process.pop(0)

    # if module_cls._has_attr_sID:
    #   attr_defaults['sID'] = sID

    # Index is never a keyword arguments - it has no defaults
    attr_no_default = []
    if module_cls._indexed:
        attr_no_default.append(attr_defaults.pop('index'))
    # ADDED: await DdeK confirmation...
    if module_cls._has_attr_sID and sID != None:
        attr_no_default.append(sID)
    # ADDED: await DdeK confirmation...
    if attr_no_default:
        # ADDED...
        # print('attr_no_default: ', attr_no_default)
        # print('attr_defaults: ', attr_defaults)
        # ADDED...
        return module_cls(*attr_no_default, **attr_defaults)
    else:
        return module_cls(**attr_defaults)


def _to_gwa(module_inst):
    '''
    Automated compiling of gwa syntax from a module class's attributes.
    :param module_inst: module instance (Node, BeamLoad etc.) for which the gwa record will be compiled. See
    _Module class for more information.
    :return: a gwa record compiled from the attributes of the module instance.
    '''
    attr_syntax_rename = {v: k for k, v in module_inst._syntax_attr_rename.items()}
    syntax_attr = list(re.sub(r'\s+', '', module_inst._syntax).split('|'))[1:]
    if module_inst._has_attr_sID:
        gwa = [module_inst._module_name + _write_sID(module_inst.sID)]
    else:
        gwa = [module_inst._module_name]
    gwa_attr = {}
    # Expanded syntax recess list
    syntax_recess_exp = []
    for x in module_inst._syntax_recess:
        syntax_recess_exp += list(x)

    while syntax_attr:
        if syntax_attr[0] in syntax_recess_exp:
            for recess_attr in module_inst._syntax_recess:
                if syntax_attr[0] in recess_attr:
                    if len(recess_attr) == 1:
                        gwa_attr.update({recess_attr[0]: module_inst._syntax_recess[recess_attr](module_inst.__dict__)})
                    else:
                        gwa_attr.update(zip(recess_attr, module_inst._syntax_recess[recess_attr](module_inst.__dict__)))
                    for attr in recess_attr:
                        syntax_attr.remove(attr)
                    break
        elif syntax_attr[0] in attr_syntax_rename:
            gwa_attr.update({syntax_attr[0]: module_inst.__dict__[attr_syntax_rename[syntax_attr[0]]]})
            syntax_attr.pop(0)
        else:
            gwa_attr.update({syntax_attr[0]: module_inst.__dict__[syntax_attr[0]]})
            syntax_attr.pop(0)
    # Default to string if no raw attr -> gwa attr function exists
    for attr in gwa_attr:
        if attr in _raw_attr_func:
            gwa_attr[attr] = _raw_attr_func[attr][1](gwa_attr[attr])
        else:
            gwa_attr[attr] = str(gwa_attr[attr])
    syntax_attr = list(re.sub(r'\s+', '', module_inst._syntax).split('|'))[1:]
    gwa += [gwa_attr[x] for x in syntax_attr]
    return '\t'.join(gwa)


class _Module(object):
    '''
    Default module, with default methods. This module is not used directly for instantiation, but all
    modules inherit from this module.
    '''
    _has_attr_sID = None
    _indexed = None
    # GWA syntax. By default, the names of attributes in this syntax are used to create class attributes
    _syntax = None
    # Certain attributes require further processing from raw gwa attributes to processed gsapy attributes
    _syntax_process = {}
    # These functions work in the reverse direction, from processed to raw
    _syntax_recess = {}
    # Certain attributes are renamed as the syntax name is not valid or undesirable
    #  This is a dictionary with key = python name, and value = GWA name
    _syntax_attr_rename = {}
    # _attr is the list of all gsapy attributes for the class, but does not include sID. sID is parsed using
    # _has_attr_sID
    _attr = []
    # Certain modules in GSA are submodules of other modules. I.e. LOAD_BEAM_LINE is a submodel of LOADBEAM -
    # in order to get LOAD_BEAM_LINE values, LOAD_BEAM must be called via GWA, but written using LOAD_BEAM_LINE syntax.
    # LOAD_BEAM must also use LOAD_BEAM_LINE (and other constructors of its submodules) to return pyGSA objects - no
    # LOAD_BEAM class is ever returned.
    _is_super = False

    # This class has no constructor. All inheriting subclasses must implement their own constructors
    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        return _from_gwa(cls, gwa)

    def to_gwa(self):
        """

        :return:
        """
        return _to_gwa(self)

    def __str__(self):
        return self.to_gwa()

    def __repr__(self):
        return self.to_gwa()

    def __eq__(self, other):
        return self.to_gwa() == other.to_gwa()


class _ModuleOrdered(_Module):
    '''
    Ordered modules are multi-record and can have gaps in the record. All records are referred to by index.
    '''
    _has_attr_sID = True
    _indexed = True


class _ModuleCollection(_Module):
    '''
    Collection modules are multi-record but have no gaps in the record.
    '''
    _has_attr_sID = True
    _indexed = False


class _ModuleSpecification(_Module):
    '''
    Specification modules are single-record.
    '''
    _has_attr_sID = False
    _indexed = False


# class ModuleResult(_Module):
#     '''
#     Result modules are not currently in use. All results are accessed using GSA.gsa.Output_Init_Arr
#     '''
#     _has_attr_sID = False


########################################################################################################################
# Geometry
########################################################################################################################

class Axis(_ModuleOrdered):
    """

    """
    _module_name = 'AXIS'
    _syntax = 'AXIS | num | name | type | Ox | Oy | Oz | Xx | Xy | Xz | XYx | XYy | XYz'
    _attr = ['index', 'name', 'type', 'origin', 'x_vector', 'xy_vector']
    _syntax_process = {('origin',): lambda raw_attr: [float(raw_attr[x]) for x in ['Ox', 'Oy', 'Oz']],
                       ('x_vector',): lambda raw_attr: [float(raw_attr[x]) for x in ['Xx', 'Xy', 'Xz']],
                       ('xy_vector',): lambda raw_attr: [float(raw_attr[x]) for x in ['XYx', 'XYy', 'XYz']]}
    _syntax_recess = {('Ox', 'Oy', 'Oz'): lambda attr: [str(x) for x in attr['origin']],
                      ('Xx', 'Xy', 'Xz'): lambda attr: [str(x) for x in attr['x_vector']],
                      ('XYx', 'XYy', 'XYz'): lambda attr: [str(x) for x in attr['xy_vector']]}
    _syntax_attr_rename = {'index': 'num'}

    # Defaults
    name_default = ''
    type_default = AxisEnum.CARTESIAN
    origin_default = [0, 0, 0]
    x_vector_default = [1, 0, 0]
    xy_vector_default = [0, 1, 0]

    def __init__(self, index, sID=None, name=name_default, type=type_default, origin=origin_default,
                 x_vector=x_vector_default, xy_vector=xy_vector_default):
        self.sID = sID
        self.index = index
        self.name = name
        self.type = type
        self.origin = origin
        self.x_vector = x_vector
        self.xy_vector = xy_vector


# TODO Area is not yet implemented
# class Area(_ModuleOrdered):
#     _module_name = 'AREA'
#     _module_syntax = 'AREA.2 | ref | name | colour | type | span | property | group | lines | coefficient',
#     _attr = []


class Node(_ModuleOrdered):
    ''' Uses NODE.3 syntax:
    I've not worked out the full chang in sysntax yet, this is based on what i've found by trial and error
    NODE.3 | num | name | colour | x | y | z | restraint | axis | mesh size |
    springProperty | massProperty | damperProperty
    '''
    _module_name = 'NODE.3'
    _enum = EntityEnum.NODE
    name_default = None
    colour_default = Colours.none
    coords_default = [0, 0, 0]
    restraint_default = "free"
    axis_default = NodeAxisEnum.GLOBAL
    mesh_size_default = None  # confirm default
    spring_property_default = None  # confirm default
    mass_property_default = None  # confirm default
    damper_property_default = None  # confirm default

    def __init__(self, index, name=name_default, colour=colour_default, coords=coords_default,
                 restraint=restraint_default, axis=axis_default, mesh_size=mesh_size_default,
                 spring_property=spring_property_default, mass_property=mass_property_default,
                 damper_property=damper_property_default, sID=''):
        self.index = index
        self.name = name
        self.colour = colour
        self.coords = coords
        self.restraint = restraint  # confirm default
        self.axis = axis
        self.mesh_size = mesh_size  # confirm default
        self.spring_property = spring_property  # confirm default
        self.mass_property = mass_property  # confirm default
        self.damper_property = damper_property  # confirm default
        self.sID = sID

    @classmethod
    def from_gwa(cls, gwa):
        """
        :param gwa:
        :return:
        """
        tokens = deque(gwa)
        record_sid, index, name, colour, coords = tokens.popleft(), int(tokens.popleft()), sq(
            tokens.popleft()), tokens.popleft(), \
                                                  [float(tokens.popleft()) for x in range(3)]
        _, sID = _parse_record_sID(record_sid)

        # RESTRAINT
        restraint = None
        if tokens:
            restraint = sq(tokens.popleft())

        # All nodes have GLOBAL axis unless otherwise specified
        axis = NodeAxisEnum.GLOBAL
        if tokens:
            axis = tokens.popleft()
            try:
                axis = int(axis)
            except ValueError:
                pass

        # mesh_size
        mesh_size = None
        if tokens:
            mesh_size = float(tokens.popleft())

        # spring_property, mass_property, damper_property...
        spring_property, mass_property, damper_property = None, None, None
        if tokens:
            spring_property = tokens.popleft()
        if tokens:
            mass_property = tokens.popleft()
        if tokens:
            damper_property = tokens.popleft()

        # restraints = None
        # grid = None
        # mesh = None
        # stiffness = None
        # # GRID
        # if tokens:
        #     if tokens[0] == 'GRID':
        #         # TODO parse grid information correctly
        #         print('Node grid data is not currently implemented')
        #         tokens.popleft()  # Discard "GRID"
        #         grid_plane = tokens.popleft()
        #         datum = tokens.popleft()
        #         gl_a = tokens.popleft()
        #         gl_b = tokens.popleft()
        #         grid = [grid_plane, datum, gl_a, gl_b]
        #     elif tokens[0] == 'NO_GRID':
        #         tokens.popleft()  # Discard "NO_GRID"
        #
        # # AXIS
        # if tokens:
        #     axis = int(tokens.popleft())
        #
        # # Restraint
        # if tokens:
        #     if tokens[0] == "REST":
        #         tokens.popleft()
        #         restraints = [bool(int(tokens.popleft())) for x in range(6)]  # 6 dof per node
        #     elif tokens[0] == 'NO_REST':
        #         tokens.popleft()
        #
        # # Stiffness
        # if tokens:
        #     if tokens[0] == "STIFF":
        #         tokens.popleft()
        #         stiffness = [float(tokens.popleft()) for x in range(6)]  # 6 dof per node
        #     elif tokens[0] == 'NO_STIFF':
        #         tokens.popleft()
        #
        # # Mesh Info
        # if tokens:
        #     # TODO - proper mesh support
        #     print('Node mesh data is not currently supported')
        #     # if tokens[0] == "MESH":
        #     #    tokens.popleft()
        #     #    mesh = [tokens.popleft() for x in range(9)]
        #     # elif tokens[0] == 'NO_MESH':
        #     #    tokens.popleft()
        #
        # # if tokens:
        # #    e_str = 'Excess parameters have been encountered while parsing node {} - parameters {} could not be parsed'
        # #    raise GSAError(e_str.format(index, '\t'.join([x for x in tokens])))
        return cls(index, name=name, colour=colour, coords=coords, restraint=restraint,
                   axis=axis, mesh_size=mesh_size, spring_property=spring_property,
                   mass_property=mass_property, damper_property=damper_property, sID=sID)

    def to_gwa(self):
        """

        :return:
        """
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.colour, *self.coords]
        # if self.grid:
        #     write += ['GRID', *self.grid]
        # else:
        #     write += ['NO_GRID']
        write += [self.restraint if self.restraint != None else '']
        write += [int(self.axis) if isinstance(self.axis, int) else self.axis]
        write += [int(self.mesh_size) if self.mesh_size != None else '']
        write += [self.spring_property if self.spring_property != None else '']  # confirm default values
        write += [self.mass_property if self.mass_property != None else '']  # confirm default values
        write += [self.damper_property if self.damper_property != None else '']  # confirm default values

        # if self.restraints:
        #     write += ['REST', *[str(int(x)) for x in self.restraints]]
        # else:
        #     write += ['NO_REST']
        # if self.stiffness:
        #     write += ['STIFF', *[str(x) for x in self.stiffness]]
        # else:
        #     write += ['NO_STIFF']
        # if self.mesh:
        #     write += ['MESH', *self.mesh]
        # else:
        #     write += ['NO_MESH']
        return '\t'.join([str(x) for x in write])

    def __str__(self):
        return self.to_gwa()

    def __repr__(self):
        return self.to_gwa()

    def __eq__(self, other):
        '''
        :param other: Node to compare against
        :return: True if all attributes EXCEPT INDEX are equal
        '''
        return reduce(lambda x, y: x and y, [self.coords == other.coords, self.restraint == other.restraint,
                                             self.name == other.name, self.colour == other.colour,
                                             self.axis == other.axis,
                                             self.mesh_size == other.mesh_size,
                                             self.spring_property == other.spring_property,
                                             self.mass_property == other.mass_property,
                                             self.damper_property == other.damper_property,
                                             self.sID == other.sID])


class Element(_ModuleOrdered):
    '''
    Uses EL.4 syntax | num | name | colour | type | prop | group | topo() | orient_node | orient_angle |
                        is_rls { | rls { | k } } off_x1 | off_x2 | off_y | off_z | dummy | parent
    '''
    _module_name = 'EL.4'
    _enum = EntityEnum.EL
    degrees = {ElementEnum.TYPE_BAR: 2,
               ElementEnum.TYPE_BEAM: 2,
               ElementEnum.TYPE_TIE: 2,
               ElementEnum.TYPE_STRUT: 2,
               ElementEnum.TYPE_ROD: 2,
               ElementEnum.TYPE_SPRING: 2,
               ElementEnum.TYPE_DAMPER: 2,
               ElementEnum.TYPE_LINK: 2,
               ElementEnum.TYPE_CABLE: 2,
               ElementEnum.TYPE_SPACER: 2,
               ElementEnum.TYPE_MASS: 1,
               ElementEnum.TYPE_GROUND_SPRING: 1,
               ElementEnum.TYPE_GROUND_DAMPER: 1,
               ElementEnum.TYPE_TRI3: 3,
               ElementEnum.TYPE_TRI6: 6,
               ElementEnum.TYPE_QUAD4: 4,
               ElementEnum.TYPE_QUAD8: 8,
               ElementEnum.TYPE_BRICK8: 8}

    _offset_types = {ElementEnum.TYPE_BAR: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_BEAM: ElementEnum.OFFSET_BEAM_DIM,
                     ElementEnum.TYPE_TIE: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_STRUT: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_ROD: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_SPRING: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_DAMPER: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_LINK: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_CABLE: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_SPACER: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_MASS: ElementEnum.OFFSET_SPACE_DIM,
                     ElementEnum.TYPE_GROUND_SPRING: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_GROUND_DAMPER: ElementEnum.OFFSET_NONE_DIM,
                     ElementEnum.TYPE_TRI3: ElementEnum.OFFSET_PLANAR_DIM,
                     ElementEnum.TYPE_TRI6: ElementEnum.OFFSET_PLANAR_DIM,
                     ElementEnum.TYPE_QUAD4: ElementEnum.OFFSET_PLANAR_DIM,
                     ElementEnum.TYPE_QUAD8: ElementEnum.OFFSET_PLANAR_DIM,
                     ElementEnum.TYPE_BRICK8: ElementEnum.OFFSET_NONE_DIM}

    name_default = ''
    colour_default = Colours.none
    type_default = 'BEAM'
    prop_default = 1
    group_default = 1
    topo_default = [1, 1]
    orient_node_default = 0
    orient_angle_default = 0
    releases_default = None
    offsets_default = None
    dummy_default = False
    parent_member_default = None
    action_default = "Normal"

    def __init__(self, index, sID='', name=name_default, colour=colour_default, type=type_default, prop=prop_default,
                 group=group_default, topo=topo_default, orient_node=orient_node_default,
                 orient_angle=orient_angle_default, releases=releases_default, offsets=offsets_default,
                 action=action_default, dummy=dummy_default, parent_member=parent_member_default):
        """

        :param index:
        :param sID:
        :param name:
        :param colour:
        :param type:
        :param prop:
        :param group:
        :param topo:
        :param orient_node:
        :param orient_angle:
        :param releases:
        :param offsets:
        :param dummy:
        """
        self.index = index
        self.name = name
        self.colour = colour
        self.type = type
        self.prop = prop
        self.group = group
        self.topo = topo
        self.orient_node = orient_node
        self.orient_angle = orient_angle
        self.releases = releases
        self.offsets = offsets
        self.dummy = dummy
        self.parent_member = parent_member
        self.sID = sID

    @classmethod
    def from_gwa(cls, gwa):
        # EL.4 | num | name | colour | type | prop | group | topo() | orient_node | orient_angle |
        # is_rls { | rls { | k } } off_x1 | off_x2 | off_y | off_z | action | dummy

        '''
        Interprets ELEM gwa line and returns a namedtuple of its properties
        '''
        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = sq(tokens.popleft())
        colour = tokens.popleft()
        type = tokens.popleft()
        if name == 'LEGACY_MASS' and type == "BEAM":
            type = 'MASS'
        degrees = cls.degrees[type]
        prop = tokens.popleft()
        prop = int(re.search(r"\d+", prop).group(0))
        group = int(tokens.popleft())
        topo = [int(tokens.popleft()) for x in range(degrees)]
        dummy = False

        # If either orient_node or orient_angle are present, they are written
        # Some elements do not have one or the other. GSA 8 allows values to be assigned to these in the
        # interface, but does not save them.
        # 1D orientable - Bar, Tie, Strut, Beam - orient node + angle
        # 2D orientable - Quad 4, Quad 8, Tri 4, Tri 6 - orient angle
        orient_node = 0
        orient_angle = 0
        if tokens:
            if tokens[0].isnumeric():
                orient_node = int(tokens.popleft())
                orient_angle = float(tokens.popleft())

        # EL.3 does not always return RLS and OFFSET data. It is assumed that if OFFSET data exists, RLS will also be returned.
        releases = None
        offsets = None
        if tokens:
            tokens, releases = cls.release_from_gwa(tokens, degrees)
            # Change from 4-dim to dimension suitable to element type
            offsets = [float(tokens.popleft()) for i in range(4)]
            if cls._offset_types[type] == ElementEnum.OFFSET_NONE_DIM:
                offsets = None
            elif cls._offset_types[type] == ElementEnum.OFFSET_PLANAR_DIM:
                offsets = [offsets[3]]
            elif cls._offset_types[type] == ElementEnum.OFFSET_SPACE_DIM:
                offsets = [offsets[0]] + offsets[2:4]

        # Dummy status may or may not be returned
        if tokens:
            dummy = tokens.popleft()
            if dummy == 'DUMMY':
                dummy = True
            elif dummy == '':
                dummy = False
            else:
                raise GSAError('Unknown parameter encountered while parsing element GWA')

        # Parent member
        if tokens:
            parent_member = tokens.popleft()
        else:
            parent_member = None

        return cls(index, sID=sID, name=name, colour=colour, type=type, prop=prop, group=group, topo=topo,
                   orient_node=orient_node, orient_angle=orient_angle, releases=releases,
                   offsets=offsets, dummy=dummy, parent_member=parent_member)

    def to_gwa(self):
        """

        :return:
        """
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.colour, self.type, self.prop,
                 self.group,
                 *self.topo]
        releases_gwa = self.release_to_gwa(self.releases)
        if self.offsets is None:
            offsets_gwa = [0.0, 0.0, 0.0, 0.0]
        elif self._offset_types[self.type] == ElementEnum.OFFSET_NONE_DIM:
            offsets_gwa = [0.0, 0.0, 0.0, 0.0]
        elif self._offset_types[self.type] == ElementEnum.OFFSET_PLANAR_DIM:
            offsets_gwa = [0.0, 0.0, 0.0, self.offsets[0]]
        elif self._offset_types[self.type] == ElementEnum.OFFSET_SPACE_DIM:
            offsets_gwa = [self.offsets[0], 0.0, self.offsets[1], self.offsets[2]]
        else:
            offsets_gwa = self.offsets
        write += [self.orient_node] if self.orient_node else ['0']
        write += [self.orient_angle] if self.orient_angle else ['0.0']
        write += [releases_gwa]
        write += offsets_gwa
        if self.dummy:
            write += ['DUMMY']
        else:
            write += [""]

        return '\t'.join([str(x) for x in write])

    def __repr__(self):
        return self.to_gwa()

    def __str__(self):
        return self.to_gwa()

    def __eq__(self, other):
        '''
        :param other: Other to compare against
        :return: True if all attributes EXCEPT INDEX are equal
        '''
        return reduce(lambda x, y: x and y, [self.name == other.name, self.colour == other.colour,
                                             self.type == other.type, self.prop == other.prop,
                                             self.group == other.group,
                                             self.topo == other.topo, self.orient_node == other.orient_node,
                                             self.orient_angle == other.orient_angle, self.releases == other.releases,
                                             self.offsets == other.offsets,
                                             self.dummy == other.dummy, self.sID == other.sID])

    @staticmethod
    def release_from_gwa(tokens, degrees):
        '''
        Each node in an element can have the following releases:

        * 0D - unreleasable (Ground Spring, Mass)
        * 1D - unreleasable (Bar, Tie, Strut, Cable, Link, Spacer, Spring)
        * 1D - releasable (Beam) - Fixed, Released, Stiffness
        * 2D - (Quad4, Quad8, Tri3, Tri6) - Fixed or Released
        * Release entries are in form x,y,z,xx,yy,zz (translation + rotation) or x,y,z (translation)
        * Releases are always local.
        * R = release
        * F = fixed
        * K = stiffness

        :param tokens: deque of gwa_command to parse
        :param degrees: degrees of freedom for interpreting releases
        :return: gwa file, and list of lists of releases, one list of releases per node.
                 Each item in the list of releases is either 'F', 'R', or the stiffness value as a float.
        '''
        if tokens[0] in ['RLS', 'NO_RLS']:
            var = tokens.popleft()
            if var.upper() == 'RLS':
                releases = []
                for node in range(degrees):
                    rls = [*tokens.popleft().upper()]
                    stiff_count = rls.count(ElementEnum.RLS_STIFF)
                    if stiff_count:
                        stiff_val = deque([float(tokens.popleft()) for x in range(stiff_count)])
                        for j, r in enumerate(rls):
                            if r == ElementEnum.RLS_STIFF:
                                rls[j] = stiff_val.popleft()
                    releases.append(rls)
                return tokens, releases
            elif var == 'NO_RLS':
                return tokens, None
        else:
            return tokens, None

    @staticmethod
    def release_to_gwa(releases):
        """

        :param releases:
        :return:
        """
        if releases:
            gwa = 'RLS'
            for rls in releases:
                stiff = []
                release = ''
                for dof in rls:
                    if isinstance(dof, float):
                        stiff.append(dof)
                        release += ElementEnum.RLS_STIFF
                    else:
                        release += str(dof)
                gwa += '\t' + release
                if stiff:
                    gwa += '\t'.join([''] + [str(x) for x in stiff])
            return gwa
        else:
            return 'NO_RLS'


class Member(_ModuleOrdered):
    '''
    Uses MEMB.8 syntax from GSA 10.1
    '''
    _module_name = 'MEMB.8'
    _enum = MemberEnum

    types_1D = ("1D_GENERIC", "BEAM", "BAR", "STRUT", "TIE", "ROD", "LINK", "SPRING")
    types_2D = ("2D_GENERIC", "LINEAR", "PARABOLIC", "RIGID")
    types_3D = ("3D_GENERIC",)

    yes_no_map = {'YES': True, 'NO': False}
    is_dummy_map = {'DUMMY': True, 'ACTIVE': False}

    name_default = ''
    colour_default = Colours.none
    member_type_default = MemberEnum.TYPE_1D_GENERIC
    exposure_default = MemberEnum.EXPOSURE_ALL
    topo_default = [1, 2]
    prop_default = 1
    group_default = None
    orient_node_default = 0
    orient_angle_default = 0
    mesh_size_default = 1
    is_intersector_default = True
    analysis_type_default = ElementEnum.TYPE_BEAM

    fire_resistance_default = 0
    limiting_temperature_default = 550
    times_default = [0, 0, 0, 0]
    dummy_default = False
    releases_default = [['F', 'F', 'F', 'F', 'F', 'F'], ['F', 'F', 'F', 'F', 'F', 'F']]
    restraints_default = ""
    effective_length_default = {'method': MemberEnum.EFFECTIVE_LENGTH_AUTOMATIC}
    load_height_default = 0
    load_height_reference_point_default = MemberEnum.LOAD_HEIGHT_SHEAR_CENTRE
    is_off_default = 'NO_OFF'
    offset_auto_default = {'off_auto_x1': 'MAN', 'off_auto_x2': 'MAN'}
    offset_default = [0, 0, 0, 0]
    reinforcement_2d_default = None

    def __init__(self,
                 index,
                 name='',
                 colour=Colours.none,
                 member_type=MemberEnum.TYPE_1D_GENERIC,
                 exposure=exposure_default,
                 prop=prop_default,
                 group=group_default,
                 topo=topo_default,
                 orient_node=orient_node_default,
                 orient_angle=orient_angle_default,
                 mesh_size=mesh_size_default,
                 is_intersector=is_intersector_default,
                 analysis_type=analysis_type_default,
                 fire_resistance=fire_resistance_default,
                 limiting_temperature=limiting_temperature_default,
                 times=times_default,
                 dummy=dummy_default,
                 releases=releases_default,
                 restraints=restraints_default,
                 effective_length=effective_length_default,
                 load_height=load_height_default,
                 load_ref=load_height_reference_point_default,
                 is_off=is_off_default,
                 offset_auto=offset_auto_default,
                 offset=offset_default,
                 reinforcement_2d=reinforcement_2d_default,
                 sID=''):
        self.index = index
        self.name = name
        self.colour = colour
        self.member_type = member_type
        self.exposure = exposure
        self.prop = prop
        self.group = group
        self.topo = topo
        self.orient_node = orient_node
        self.orient_angle = orient_angle
        self.mesh_size = mesh_size
        self.is_intersector = is_intersector
        self.analysis_type = analysis_type
        self.fire_resistance = fire_resistance
        self.limiting_temperature = limiting_temperature
        self.times = times
        self.dummy = dummy
        self.releases = releases
        self.restraints = restraints
        self.effective_length = effective_length
        self.load_height = load_height
        self.load_ref = load_ref
        self.is_off = is_off
        self.offset_auto = offset_auto
        self.offset = offset
        self.sID = sID
        self.reinforcement_2d = reinforcement_2d

    @classmethod
    def from_gwa(cls, gwa):
        # MEMB.8 | num | name | colour | type (1D) | prop | group | topology | node | angle |
        # is_composite | mesh_size | is_intersector | analysis_type | fire | limit | time[4] |
        # dummy | is_rls { | rls { | k } } | restraint_end_1 | restraint_end_2 | AUTOMATIC | height
        # | load_ref | stud_layout off_auto_x1 | off_auto_x2 | off_auto_internal | off_x1 | off_x2 | off_y | off_z | exposure

        # MEMB.8 | num | name | colour | type (1D) | prop | group | topology | node | angle |
        # is_composite | mesh_size | is_intersector | analysis_type | fire | limit | time[4] |
        # dummy | is_rls { | rls { | k } } | restraint_end_1 | restraint_end_2 | AUTOMATIC | height
        # | load_ref | stud_layout off_auto_x1 | off_auto_x2 | off_auto_internal | off_x1 | off_x2 | off_y | off_z | exposure

        # MEMB.8 | num | name | colour | type (1D) | prop | group | topology | node | angle |
        # is_composite | mesh_size | is_intersector |analysis_type | fire | time[4]
        #  dummy | is_rls { | rls { | k } } | restraint_end_1 | restraint_end_2 | EXPLICIT | nump |
        # { point | rest | } | nums | { span | rest | } height | load_ref | stud_layout | off_auto_x1 | off_auto_x2 | off_auto_internal
        # | off_x1 | off_x2 | off_y | off_z | exposure

        # MEMB.8 | num | name | colour | type (2D) | prop | group | topology | node | angle |
        # is_composite | mesh_size | is_intersector | analysis_type | fire | time[4] |
        # dummy | off_auto_internal | off_z | exposure

        '''
        Interprets MEMB gwa line and returns a named tuple of its properties
        '''
        gwa_error = gwa
        args = {}

        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, args['sID'] = _parse_record_sID(record_sID)  # TODO: check and log version of data format?
        args['index'] = int(tokens.popleft())
        args['name'] = sq(tokens.popleft())
        args['colour'] = tokens.popleft()
        args['member_type'] = tokens.popleft()
        if args['member_type'] in cls.types_1D or args['member_type'] in cls.types_2D:
            args['exposure'] = tokens.popleft()
        args['prop'] = int(tokens.popleft())
        args['group'] = int(tokens.popleft())  # leave as string
        args['topo'] = tokens.popleft()
        # If either node or angle are present, they are written

        # section = int(tokens.popleft())

        num_nodes = len(args['topo'])

        # If either orient_node or orient_angle are present, they are written
        # Some elements do not have one or the other. GSA 8 allows values to be assigned to these in the
        # interface, but does not save them.
        # 1D orientable - Bar, Tie, Strut, Beam - orient node + angle
        # 2D orientable - Quad 4, Quad 8, Tri 4, Tri 6 - orient angle
        args['orient_node'] = 0
        args['orient_angle'] = 0
        if tokens:
            if tokens[0].isnumeric():
                args['orient_node'] = int(tokens.popleft())
                args['orient_angle'] = float(tokens.popleft())

        # Not a member variable
        # Is composite
        # args['is_composite'] = False
        # if not is_float(tokens[0]):
        #    args['is_composite'] = True if tokens.popleft() == "YES" else False

        args['mesh_size'] = int(tokens.popleft())
        args['is_intersector'] = cls.yes_no_map[tokens.popleft()]

        args['analysis_type'] = tokens.popleft()
        args['fire_resistance'] = int(tokens.popleft())
        if args['member_type'] in cls.types_1D or args['member_type'] in cls.types_2D:
            args['limiting_temperature'] = int(tokens.popleft())
        args['times'] = [int(tokens.popleft()) for _ in range(4)]

        try:
            args['dummy'] = cls.is_dummy_map[tokens.popleft()]
        except KeyError:
            raise GSAError("Error parsing dummy of [" + " ".join(gwa) + "]")

        # at this point, the 1D, 2D and 3D syntax diverges completely
        if args['member_type'] in cls.types_1D:
            args['releases'] = [[], []]
            for r in tokens.popleft():
                if r == 'K':
                    args['releases'][0].append(float(tokens.popleft()))
                else:
                    args['releases'][0].append(r)

            for r in tokens.popleft():
                if r == 'K':
                    args['releases'][1].append(float(tokens.popleft()))
                else:
                    args['releases'][1].append(r)
            # gsapy does not parse the restraint - it just passes it through
            args['restraints'] = [tokens.popleft(), tokens.popleft()]

            effective_length_method = tokens.popleft()

            if effective_length_method == 'AUTOMATIC':
                args['effective_length'] = {'method': MemberEnum.EFFECTIVE_LENGTH_AUTOMATIC}
            elif effective_length_method == 'EFF_LEN':
                args['effective_length'] = {'method': MemberEnum.EFFECTIVE_LENGTH_GIVEN,
                                            'Iyy': float(tokens.popleft()),
                                            'Izz': float(tokens.popleft()),
                                            'Ilt': float(tokens.popleft())}
            elif effective_length_method == 'EXPLICIT':
                args['effective_length'] = {'method': MemberEnum.EFFECTIVE_LENGTH_EXPLICIT,
                                            'point_restraints': [],
                                            'span_restraints': []}
                for i in range(int(tokens.popleft())):  # the next token gives the length of the following list
                    args['effective_length']['point_restraints'].append([int(tokens.popleft()), tokens.popleft()])
                for i in range(int(tokens.popleft())):  # ditto
                    args['effective_length']['span_restraints'].append([int(tokens.popleft()), tokens.popleft()])

            args['load_height'] = int(tokens.popleft())
            args['load_ref'] = tokens.popleft()

            # yes_no_map due to different output syntax from gsa no longer applicable here
            args['is_off'] = tokens.popleft()
            # try:
            #    args['is_off'] = {'is_offset': cls.yes_no_map[tokens.popleft()]}
            # except KeyError:
            #    raise GSAError("Error parsing offsets of [" + " ".join(gwa) + "]")
            if args['is_off'] == 'OFF':
                args['offset_auto'] = [tokens.popleft() for x in range(2)]
                args['offset'] = [float(tokens.popleft()) for x in range(4)]

        if args['member_type'] in cls.types_2D:
            args['offset'] = tokens.popleft()
            args['offset_auto'] = tokens.popleft()
            args['reinforcement_2d'] = list(tokens)

        if args['member_type'] in cls.types_3D:
            pass  # that's it, there is no more

        return cls(**args)

    def to_gwa(self):
        """

        :return:
        """
        write = ["MEMB.8" + _write_sID(self.sID), self.index, self.name, self.colour, self.member_type]
        if self.member_type in Member.types_1D or self.member_type in Member.types_2D:
            write += [self.exposure]
        write += [str(self.prop), str(self.group), self.topo, self.orient_node, self.orient_angle, self.mesh_size,
                  'YES' if self.is_intersector == True else 'NO', self.analysis_type, self.fire_resistance]
        if self.member_type in Member.types_1D or self.member_type in Member.types_2D:
            write += [self.limiting_temperature]
        write += self.times
        write += ['DUMMY' if self.dummy else 'ACTIVE']
        if self.member_type in Member.types_1D:
            release_one = ''
            release_two = ''
            for index in self.releases[0]:
                release_one += index
            for index in self.releases[1]:
                release_two += index
            write += [release_one, release_two]
            write += self.restraints
            write += [str(self.effective_length['method'])]
            write += str(self.load_height)
            write += [str(self.load_ref)]
            write += [str(self.is_off)]
            if self.is_off == 'OFF':
                write += [self.offset_auto[0]]
                write += [self.offset_auto[1]]
                for i in range(4):
                    write += [str(self.offset[i])]
        if self.member_type in Member.types_2D:
            write += [self.offset, self.offset_auto]
            write += self.reinforcement_2d

        return '\t'.join([str(x) for x in write])

    def __repr__(self):
        return self.to_gwa()

    def __str__(self):
        return self.to_gwa()

    @staticmethod
    def release_from_gwa(tokens, degrees):
        '''
        Each node in an element can have the following releases:

        * 0D - unreleasable (Ground Spring, Mass)
        * 1D - unreleasable (Bar, Tie, Strut, Cable, Link, Spacer, Spring)
        * 1D - releasable (Beam) - Fixed, Released, Stiffness
        * 2D - (Quad4, Quad8, Tri3, Tri6) - Fixed or Released
        * Release entries are in form x,y,z,xx,yy,zz (translation + rotation) or x,y,z (translation)
        * Releases are always local.
        * R = release
        * F = fixed
        * K = stiffness

        :param tokens: deque of gwa_command to parse
        :param degrees: degrees of freedom for interpreting releases
        :return: gwa file, and list of lists of releases, one list of releases per node.
                 Each item in the list of releases is either 'F', 'R', or the stiffness value as a float.
        '''
        releases = []
        for node in range(degrees):
            rls = [*tokens.popleft().upper()]
            stiff_count = rls.count(ElementEnum.RLS_STIFF)
            if stiff_count:
                stiff_val = deque([float(tokens.popleft()) for x in range(stiff_count)])
                for j, r in enumerate(rls):
                    if r == ElementEnum.RLS_STIFF:
                        rls[j] = stiff_val.popleft()
            releases.append(rls)
        return tokens, releases

    @staticmethod
    def release_to_gwa(releases):
        """

        :param releases:
        :return:
        """
        if releases:
            for rls in releases:
                stiff = []
                release = ''
                for dof in rls:
                    if isinstance(dof, float):
                        stiff.append(dof)
                        release += ElementEnum.RLS_STIFF
                    else:
                        release += str(dof)
                gwa += '\t' + release
                if stiff:
                    gwa += '\t'.join([''] + [str(x) for x in stiff])
            return gwa


class Rebar_Layout(_ModuleOrdered):
    '''
    Uses REBAR_2D.1 syntax
    '''

    def __init__(self):

        cover_top = cover_top
        cover_bottom = cover_bottom
        num_layouts = num_layouts
        layouts = []

    @classmethod
    def from_gwa(cls, gwa):
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)

        num_layouts = int(tokens.popleft())

        for i in num_layouts:
            length_polyline = int(tokens.popleft())

            points = []
            for p in range(length_polyline):
                points.append([float(tokens.popleft()), float(tokens.popleft())])

            undef = tokens.pop_left()  # not sure what this thing is UNDEF.1
            rebar = tokens.pop_left()
            # rebar = rebar.split([" ", "+"])
            rebar = re.split(r"\s*[+\s]\s*", rebar)
            layer = rebar[0]
            bars = rebar[1:]

            layouts.append(Rebar(layer, bars, points))


class Rebar(object):
    polyline_default = []

    def __init__(self, layer, bars, polyline=polyline_default):
        self.layer = layer
        self.bars = bars
        self.polyline = polyline

    def to_gwa(self):
        write = [len(self.polyline), *self.polyline, self.undef]
        rebar = self.layer + " " + " + ".join([str(bar) for bar in self.bars])
        write.append(rebar)
        return '\t'.join([str(x) for x in write])


########################################################################################################################
#   Supplementary classes for elements
########################################################################################################################

def Beam(index, name='', colour='NO_RGB', prop=1, group=1, topo=(0, 0), orient_node=None, orient_angle=0,
         releases=None, offsets=None, action='NORMAL', dummy=False):
    """

    :param index:
    :param name:
    :param colour:
    :param prop:
    :param group:
    :param topo:
    :param orient_node:
    :param orient_angle:
    :param releases:
    :param offset_type:
    :param offsets:
    :param action:
    :param dummy:
    :return:
    """
    return Element(index, name=name, colour=colour, type=ElementEnum.TYPE_BEAM, prop=prop, group=group, topo=topo,
                   orient_node=orient_node, orient_angle=orient_angle, releases=releases, offsets=offsets,
                   action=action, dummy=dummy)


def Quad8(index, name='', colour=Colours.none, prop=1, group=1, topo=(0, 0, 0, 0, 0, 0, 0, 0), orient_angle=0,
          releases=None, offsets=None, dummy=False):
    """

    :param index:
    :param name:
    :param colour:
    :param prop:
    :param group:
    :param topo:
    :param orient_angle:
    :param releases:
    :param offset_type:
    :param offsets:
    :param dummy:
    :return:
    """
    return Element(index, name=name, colour=colour, type=ElementEnum.TYPE_QUAD8, prop=prop, group=group, topo=topo,
                   orient_angle=orient_angle, releases=releases, offsets=offsets, action='NORMAL', dummy=dummy)


def Quad4(index, name='', colour=Colours.none, prop=1, group=1, topo=(0, 0, 0, 0), orient_angle=0,
          releases=None, offsets=None, dummy=False):
    """

    :param index:
    :param name:
    :param colour:
    :param prop:
    :param group:
    :param topo:
    :param orient_angle:
    :param releases:
    :param offset_type:
    :param offsets:
    :param dummy:
    :return:
    """
    return Element(index, name=name, colour=colour, type=ElementEnum.TYPE_QUAD4, prop=prop, group=group, topo=topo,
                   orient_angle=orient_angle, releases=releases, offsets=offsets, action='NORMAL', dummy=dummy)


########################################################################################################################
# Constraints
########################################################################################################################


class ConstraintRigid(_ModuleCollection):
    '''
    Uses RIGID.3 syntax - RIGID.3 | name | master | type | slaves | stage | parent_member
    Uses RIGID.2 syntax - RIGID.2 | name | master | type | slaves | stage
    Stages are group strings, either all or group names
    Slaves are node GSA lists
    '''
    _module_name = 'RIGID.3'
    name_default = ''
    master_default = 0
    type_default = ConstraintRigidEnum.ALL
    slaves_default = None
    stage_list_default = 'all'
    parent_member_default = ''

    def __init__(self, name=name_default, sID=None, master=master_default, linkage_type=type_default,
                 slaves=slaves_default, stage_list=stage_list_default, parent_member=parent_member_default):
        self.name = name
        self.master = master
        self.type = linkage_type
        self.slaves = slaves
        self.stage_list = stage_list
        self.parent_member = parent_member
        self.sID = sID

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        _, sID = _parse_record_sID(gwa[0])
        name = sq(gwa[1])
        master = int(gwa[2])
        linkage_type = gwa[3]
        slaves = gwa[4].strip()
        stage_list = gwa[5].strip()
        parent_member = gwa[6].strip()
        if len(gwa) > 7:
            raise GSAError('Excess parameters have been encountered while parsing rigid constraint')
        return cls(name=name, sID=sID, master=master, linkage_type=linkage_type, slaves=slaves, stage_list=stage_list)

    def to_gwa(self):
        """

        :return:
        """
        return '\t'.join(str(x) for x in [self._module_name + _write_sID(self.sID),
                                          self.name, self.master, self.type, self.slaves,
                                          self.stage_list, self.parent_member])

    def __repr__(self):
        return self.to_gwa()

    def __str__(self):
        return self.to_gwa()

    def __eq__(self, other):
        return self.to_gwa() == other.to_gwa()


########################################################################################################################
# Gravity Loads
########################################################################################################################


class GravityLoad(_ModuleCollection):
    '''
    Uses LOAD_GRAVITY.3 syntax | name | elemlist | nodelist | case | x | y | z
    '''
    _module_name = 'LOAD_GRAVITY.3'
    name_default = ''
    element_list_default = 'all'
    node_list_default = 'all'
    case_default = 1
    factors_default = [0, 0, -1]

    def __init__(self, name=name_default, element_list=element_list_default, node_list=node_list_default,
                 case=case_default, factors=factors_default):
        '''
        Gravity load definition. Uses LOAD_GRAVITY.3 syntax: LOAD_GRAVITY.2 | name | elemlist | nodelist | case | x | y | z

        :param name: name of the load
        :param element_list: list of elements
        :param node_list: list of nodes
        :param case: load case number
        :param factors: gravitational accelerations in directions [x, y, z]
        '''
        self.name = name
        self.element_list = element_list
        self.node_list = node_list
        self.case = case
        self.factors = factors

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param tokens:
        :return:
        """
        tokens = deque(gwa)
        tokens.popleft()  # Discard RECORD entry
        name, elem_list, node_list, case, factors = sq(
            tokens.popleft()), tokens.popleft().strip(), tokens.popleft().strip(), \
                                                    int(tokens.popleft()), [float(tokens.popleft()) for x in range(3)]
        if tokens:
            raise GSAError('Excess parameters have been encountered while parsing gravity load')
        return cls(name=name, element_list=elem_list, case=case, factors=factors)

    def to_gwa(self):
        """

        """
        return '\t'.join(
            ['LOAD_GRAVITY.3', self.name, self.element_list, self.node_list, str(self.case)] + [str(x) for x in
                                                                                                self.factors])


########################################################################################################################
# Node Loads
########################################################################################################################


class NodeLoad(_ModuleCollection):
    """

    """
    _module_name = 'LOAD_NODE.2'
    _syntax = 'LOAD_NODE.2 | name | list | case | node_axis | dir | value'
    _attr = ['name', 'node_list', 'case', 'axis', 'drxn', 'value']
    _syntax_attr_rename = {'node_list': 'list',
                           'drxn': 'dir',
                           'axis': 'node_axis'}
    name_default = ''
    node_list_default = None
    case_default = 1
    axis_default = NodeAxisEnum.GLOBAL
    dir_default = DirEnum.Z
    value_default = 0

    def __init__(self, sID=None, name=name_default, node_list=node_list_default, case=case_default, axis=axis_default,
                 drxn=dir_default, value=value_default):
        self.sID = sID
        self.name = name
        self.node_list = node_list
        self.case = case
        self.axis = axis
        self.drxn = drxn
        self.value = value


class NodeSettlement(_ModuleCollection):
    """

    """
    _module_name = 'SETTLE.2'
    _syntax = 'SETTLE.2 | name | list | case | dir | value'
    _attr = ['name', 'node_list', 'case', 'drxn', 'value']
    _syntax_attr_rename = {'node_list': 'list',
                           'drxn': 'dir'}
    name_default = ''
    node_list_default = None
    case_default = 1
    dir_default = DirEnum.Z
    value_default = 0

    def __init__(self, sID=None, name=name_default, node_list=node_list_default, case=case_default,
                 drxn=dir_default, value=value_default):
        self.sID = sID
        self.name = name
        self.node_list = node_list
        self.case = case
        self.drxn = drxn
        self.value = value


class NodeAppliedDisplacement(_ModuleCollection):
    """

    """
    _module_name = 'DISP_NODE.2'
    _syntax = 'DISP_NODE.2 | name | list | case | axis | dir | value'
    _attr = ['name', 'node_list', 'case', 'axis', 'drxn', 'value']
    _syntax_attr_rename = {'node_list': 'list',
                           'drxn': 'dir'}
    name_default = ''
    node_list_default = None
    case_default = 1
    axis_default = NodeAxisEnum.GLOBAL
    dir_default = DirEnum.X
    value_default = 0

    def __init__(self, sID=None, name=name_default, node_list=node_list_default, case=case_default, axis=axis_default,
                 drxn=dir_default, value=value_default):
        '''
        Nodal applied displacement definiton. Uses DISP_NODE.2 syntax: DISP_NODE.2 | name | list | case | axis | dir | value
        :param name: name of the load
        :param list: list of nodes
        :param case: load case number
        :param axis: axis number (default is GLOBAL)
        :param dir: direction of applied displacement for the given axis [x, y, z]
        :param value: value of applied displacement
        '''
        self.sID = sID
        self.name = name
        self.node_list = node_list
        self.case = case
        self.axis = axis
        self.drxn = drxn
        self.value = value


########################################################################################################################
# Beam Loads
########################################################################################################################


class BeamLoad(_ModuleCollection):
    """

    """
    _module_name = 'LOAD_BEAM'
    _is_super = True

    def __init__(self):
        raise GSAError('BeamLoad cannot be used to instantiate beam load records. Use LoadBeamLinear, BeamLoadDist and '
                       'other specific BeamLoad records to instantiate beam load records')

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        module_name, _ = _parse_record_sID(gwa[0])
        # Attempt to match module name against subclass module names to find correct constructor
        for submodule in cls.__subclasses__():
            if submodule._module_name == module_name:
                return submodule.from_gwa(gwa)
        # if that doesn't work, check without versions (VERY RISKY)
        for submodule in cls.__subclasses__():
            if submodule._module_name[:submodule._module_name.find('.')] == module_name:
                return submodule.from_gwa(gwa)
        raise GSAError('Could not instantiate record {} as a beam load'.format(module_name))


class BeamLoadLinear(BeamLoad):
    """

    """
    _is_super = False
    _syntax = 'LOAD_BEAM_LINE.2 | name | list | case | beam_axis | proj | dir | value_1 | value_2'
    _attr = ['name', 'elem_list', 'case', 'axis', 'proj', 'drxn', 'values']
    _module_name = 'LOAD_BEAM_LINE.2'
    _syntax_process = {('values',): lambda raw_attr: list([raw_attr['value_1'], raw_attr['value_2']])}
    _syntax_recess = {('value_1', 'value_2'): lambda attr: attr['values']}
    _syntax_attr_rename = {'elem_list': 'list',
                           'drxn': 'dir',
                           'axis': 'beam_axis'}

    # Defaults
    name_default = ""
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    proj_default = True
    drxn_default = DirEnum.Z
    values_default = [0, 0]

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 proj=proj_default, drxn=drxn_default, values=values_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.proj = proj
        self.drxn = drxn
        self.values = values

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        return _from_gwa(cls, gwa)


class BeamLoadUniform(BeamLoad):
    """

    """
    _is_super = False
    _syntax = 'LOAD_BEAM_UDL.2 | name | list | case | beam_axis | proj | dir | value'
    _attr = ['name', 'elem_list', 'case', 'axis', 'proj', 'drxn', 'value']
    _module_name = 'LOAD_BEAM_UDL.2'
    _syntax_attr_rename = {'elem_list': 'list',
                           'drxn': 'dir',
                           'axis': 'beam_axis'}
    # Defaults
    name_default = ""
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    proj_default = True
    drxn_default = DirEnum.Z
    value_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 proj=proj_default, drxn=drxn_default, value=value_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.proj = proj
        self.drxn = drxn
        self.value = value

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        return _from_gwa(cls, gwa)


class BeamLoadDist(BeamLoad):
    """

    """
    _is_super = False
    _syntax = 'LOAD_BEAM_DIST.2 | name | list | case | dir | pos | value'
    _attr = ['name', 'elem_list', 'case', 'drxn', 'pos', 'value']
    _module_name = 'LOAD_BEAM_DIST.2'
    _syntax_attr_rename = {'elem_list': 'list',
                           'drxn': 'dir'}
    name_default = ""
    elem_list_default = None
    case_default = 1
    drxn_default = DirEnum.Z
    pos_default = 0
    value_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default,
                 drxn=drxn_default, pos=pos_default, value=value_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.drxn = drxn
        self.pos = pos
        self.value = value

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        return _from_gwa(cls, gwa)


class BeamLoadPoint(BeamLoad):
    """

    """
    _is_super = False
    _syntax = 'LOAD_BEAM_POINT.2 | name | list | case | beam_axis | proj | dir | pos | value'
    _attr = ['name', 'elem_list', 'case', 'axis', 'proj', 'drxn', 'pos', 'value']
    _module_name = 'LOAD_BEAM_POINT.2'
    _syntax_attr_rename = {'elem_list': 'list',
                           'drxn': 'dir',
                           'axis': 'beam_axis'}
    name_default = ""
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    proj_default = False
    drxn_default = DirEnum.Z
    pos_default = 0
    value_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 proj=proj_default, drxn=drxn_default, pos=pos_default, value=value_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.proj = proj
        self.drxn = drxn
        self.pos = pos
        self.value = value

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        return _from_gwa(cls, gwa)


class BeamLoadPatch(BeamLoad):
    """

    """
    _is_super = False
    _syntax = 'LOAD_BEAM_PATCH.2 | name | list | case | beam_axis | proj | dir | pos_1 | value_1 | pos_2 | value_2'
    _attr = ['name', 'elem_list', 'case', 'axis', 'proj', 'drxn', 'pos', 'values']
    _module_name = 'LOAD_BEAM_PATCH.2'
    _syntax_attr_rename = {'elem_list': 'list',
                           'drxn': 'dir',
                           'axis': 'beam_axis'}
    _syntax_process = {('values',): lambda raw_attr: [raw_attr['value_1'], raw_attr['value_2']],
                       ('pos',): lambda raw_attr: [raw_attr['pos_1'], raw_attr['pos_2']]}
    _syntax_recess = {('value_1', 'value_2'): lambda attr: attr['values'],
                      ('pos_1', 'pos_2'): lambda attr: attr['pos']}
    name_default = ""
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    proj_default = False
    drxn_default = DirEnum.Z
    pos_default = 0
    values_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 proj=proj_default, drxn=drxn_default, pos=pos_default, values=values_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.proj = proj
        self.drxn = drxn
        self.pos = pos
        self.values = values

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        return _from_gwa(cls, gwa)


class BeamLoadTrilinear(BeamLoad):
    """

    """
    _is_super = False
    _syntax = 'LOAD_BEAM_TRILIN.2 | name | list | case | beam_axis | proj | dir | pos_1 | value_1 | pos_2 | value_2'
    _attr = ['name', 'elem_list', 'case', 'axis', 'proj', 'drxn', 'pos', 'values']
    _module_name = 'LOAD_BEAM_TRILIN.2'
    _syntax_attr_rename = {'elem_list': 'list',
                           'drxn': 'dir',
                           'axis': 'beam_axis'}
    _syntax_process = {('values',): lambda raw_attr: [raw_attr['value_1'], raw_attr['value_2']],
                       ('pos',): lambda raw_attr: [raw_attr['pos_1'], raw_attr['pos_2']]}
    _syntax_recess = {('value_1', 'value_2'): lambda attr: attr['values'],
                      ('pos_1', 'pos_2'): lambda attr: attr['pos']}
    name_default = ""
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    proj_default = False
    drxn_default = DirEnum.Z
    pos_default = 0
    values_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 proj=proj_default, drxn=drxn_default, pos=pos_default, values=values_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.proj = proj
        self.drxn = drxn
        self.pos = pos
        self.values = values

    @classmethod
    def from_gwa(cls, gwa):
        """

        :param gwa:
        :return:
        """
        return _from_gwa(cls, gwa)


########################################################################################################################
# 2D & 3D Loads
########################################################################################################################

class TwoDimLoadFace(_ModuleCollection):
    """
    Based on LOAD_2D_FACE.2
    """
    _module_name = 'LOAD_2D_FACE.2'
    _syntax = 'LOAD_2D_FACE.2 | name | list | case | axis | type | proj | dir | values_1 | values_2 | values_3 | values_4'
    _syntax_attr_rename = {'elem_list': 'list'}
    _attr = ['name', 'elem_list', 'case', 'axis', 'type', 'proj', 'dir', 'values_1', 'values_2', 'values_3', 'values_4']
    name_default = ''
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    type_default = 'CONS'
    proj_default = False
    dir_default = 'Z'
    values_1_default = 0
    values_2_default = 0
    values_3_default = 0
    values_4_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 type=type_default, proj=proj_default, dir=dir_default, values_1=values_1_default,
                 values_2=values_2_default, values_3=values_3_default, values_4=values_4_default):
        '''
        Nodal applied displacement definition. Uses LOAD_2D_FACE.2

        :param name: name of the load
        :param elem_list: list of nodes
        :param case: load case number
        :param axis: axis number (default is GLOBAL)
        :param type: load type
                CONS: constant (one value for element),
                GEN: variable (one value for each corner node),
                POINT
        :param proj: flag for projected loads  ( YES / NO )
        :param dir: load direction ( X / Y / Z )
        :param values_1: load values [N/m²] (similar for values_n inputs)
        '''
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.type = type
        self.proj = proj
        self.dir = dir
        self.values_1 = values_1
        self.values_2 = values_2
        self.values_3 = values_3
        self.values_4 = values_4



    @classmethod
    def from_gwa(cls, gwa):
        gwa_error = gwa
        args = {}
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, args['sID'] = _parse_record_sID(record_sID)  # TODO: check and log version of data format?
        args['name'] = tokens.popleft()
        args['elem_list'] = tokens.popleft()
        args['case'] = tokens.popleft()
        args['axis'] = tokens.popleft()
        args['type'] = tokens.popleft()
        args['proj'] = tokens.popleft()
        args['dir'] = tokens.popleft()
        if args['type'] == 'CONS':
            args['values_1'] = tokens.popleft()
        elif args['type'] == 'GEN':
            args['values_1'] = tokens.popleft()
            args['values_2'] = tokens.popleft()
            args['values_3'] = tokens.popleft()
            args['values_4'] = tokens.popleft()
        elif args['type'] == 'POINT':
            args['values_1'] = tokens.popleft()
            args['values_2'] = tokens.popleft()
            args['values_3'] = tokens.popleft()

        return cls(**args)

    def to_gwa(self):
        """
        :return:
        """
        write = ['LOAD_2D_FACE.2', self.name, self.elem_list, self.case, self.axis, self.type]
        if self.proj == True:
            write += ['YES']
        elif self.proj == False:
            write += ['NO']
        else:
            write += self.proj
        write += [self.dir]
        if self.type == 'CONS':
            write += [self.values_1]
        elif self.type == 'GEN':
            write += [self.values_1, self.values_2, self.values_3, self.values_4]
        elif self.type == 'POINT':
            write += [self.values_1, self.values_2, self.values_3]

        return '\t'.join([str(x) for x in write])


class TwoDimLoadEdge(_ModuleCollection):
    """
    Based on LOAD_2D_EDGE.2
    """
    _module_name = 'LOAD_2D_EDGE.2'
    _syntax = 'LOAD_2D_EDGE.2 | name | list | case | axis | edge | dir | value_1 | value_2'
    _syntax_attr_rename = {'elem_list': 'list'}
    _attr = ['name', 'elem_list', 'case', 'axis', 'edge', 'dir', 'value_1', 'value_2']
    name_default = ''
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    edge_default = '1'
    dir_default = 'Z'
    value_1_default = 0
    value_2_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 edge=edge_default, dir=dir_default, value_1=value_1_default, value_2=value_2_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.edge = edge
        self.dir = dir
        self.value_1 = value_1
        self.value_2 = value_2


class ThreeDimLoadFace(_ModuleCollection):
    """
    Based on LOAD_3D_FACE.2
    """
    _module_name = 'LOAD_3D_FACE.2'
    _syntax = 'LOAD_3D_FACE.2 | name | list | case | axis | type | proj | face | dir | value(n)'
    _syntax_attr_rename = {'elem_list': 'list'}
    _attr = ['name', 'elem_list', 'case', 'axis', 'type', 'proj', 'face', 'dir', 'values']
    name_default = ''
    elem_list_default = None
    case_default = 1
    axis_default = 'GLOBAL'
    type_default = 'CONS'
    proj_default = False
    face_default = 0
    dir_default = 'Z'
    values_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default, axis=axis_default,
                 type=type_default, proj=proj_default, face=face_default, dir=dir_default, values=values_default):
        '''
                Uses LOAD_2D_FACE.3


                proj	flag for projected loads
                        YES | NO
                face	face index
                        0	Bottom
                        1	Top
                        2	Front
                        3	Right
                        4	Back
                        5	Left
                dir	load direction
                X | Y | Z
                value()	load values [N/m³]

                :param name:    name of the load
                :param list:    list of nodes
                :param case:    load case number
                :param axis:    axis number (default is GLOBAL)
                :param type:    load type
                        CONS	constant (one value for element)
                        GEN	    variable (one value for each corner node)
                :param proj:    flag for projected loads  ( YES / NO )
                :param face	    face index
                        0	Bottom
                        1	Top
                        2	Front
                        3	Right
                        4	Back
                        5	Left
                :param dir: load direction ( X / Y / Z )
                :param value(n) load values [N/m²]
                '''
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.axis = axis
        self.type = type
        self.proj = proj
        self.face = face
        self.dir = dir
        self.values = values



    @classmethod
    def from_gwa(cls, gwa):
        gwa_error = gwa
        args = {}
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, args['sID'] = _parse_record_sID(record_sID)  # TODO: check and log version of data format?
        args['name'] = tokens.popleft()
        args['elem_list'] = tokens.popleft()
        args['case'] = tokens.popleft()
        args['axis'] = tokens.popleft()
        args['type'] = tokens.popleft()
        args['proj'] = tokens.popleft()
        args['face'] = tokens.popleft()
        args['dir'] = tokens.popleft()
        args['values'] = []
        while tokens:
            args['values'].append(tokens.popleft())

        return cls(**args)

    # 'LOAD_3D_FACE.2 | name | list | case | axis | type | proj | face | dir | value(n)'
    def to_gwa(self):
        """
        :return:
        """
        write = ['LOAD_3D_FACE.2', self.name, self.elem_list, self.case, self.axis, self.type]
        if self.proj == True:
            write += ['YES']
        elif self.proj == False:
            write += ['NO']
        else:
            write += self.proj
        write += [self.face, self.dir]
        if self.type == 'CONS':
            if type(self.type) == list:
                write += [self.values[0]]
            else:
                write += [self.values]
        elif self.type == 'GEN':
            write += self.values

        return '\t'.join([str(x) for x in write])


# TODO: Wait for Oasys to work on GWAcommand with accessing LOAD_2D_PRE.2, LOAD_2D_TENDON.2, LOAD_2D_STRN.2
'''
class TwoDimLoadPrestress(_ModuleCollection):
    _module_name = 'LOAD_2D_PRE.2'
    _syntax = 'LOAD_2D_PRE.2 | name | list | case | dir | value'
    _syntax_attr_rename = {'elem_list': 'list'}
    _attr = ['name', 'elem_list', 'case', 'dir', 'value']
    name_default = ''
    elem_list_default = None
    case_default = 1
    dir_default = 'BOTH'
    value_default = 0

    def __init__(self, sID=None, name=name_default, elem_list=elem_list_default, case=case_default,
                 dir=dir_default, value=value_default):
        self.sID = sID
        self.name = name
        self.elem_list = elem_list
        self.case = case
        self.dir = dir
        self.value = value
'''


########################################################################################################################
# User Modules
########################################################################################################################


class UserModuleElement(_ModuleOrdered):
    '''
    Uses USER_MOD_ELEM_TITLE.2 syntax from GSA 10.1

    User modules for elements.

    :param index: index
    :param sID: sID
    :param name: name
    :param colour: colour
    :param axis: axis to display in
    :param dir: diagram direction
    :param dimension: units for module
    :param contour: contour type
    :param is_centre: user module is configured for centre values only on 2D elements, or not
    :param data: list of [element, position, value] of user module data

    '''
    _module_name = "USER_MOD_ELEM_TITLE.2"
    _syntax = "USER_MOD_ELEM_TITLE.2 | module | name | colour | axis | dir | dimension | blob | is_centre"
    _attr = ['index', 'name', 'colour', 'axis', 'dir', 'dimension', 'contour', 'is_centre']
    _syntax_attr_rename = {
        'index': 'module',
        'contour': 'blob'
    }

    colour_default = Colours.none
    axis_default = UserModuleAxisEnum.GLOBAL
    dir_default = UserModuleEnum.DIR_NONE
    dimension_default = 'NULL'
    contour_default = UserModuleEnum.CONTOUR_BLOB
    is_centre_default = UserModuleEnum.IS_CENTRE_VALUE_ONLY_NO

    data_default = None

    def __init__(self, index, name, colour=colour_default, axis=axis_default,
                 dir=dir_default, dimension=dimension_default, contour=contour_default, is_centre=is_centre_default,
                 data=data_default, sID=''):
        self.index = index
        self.sID = sID
        self.name = name
        self.colour = colour
        self.axis = axis
        self.dir = dir
        self.dimension = dimension
        self.contour = contour
        self.is_centre = is_centre
        if data is None:
            self.data = []
        else:
            self.data = data.copy()

    def add_data(self, element, position, value):
        '''
        Add data to user module.

        :param element: element index
        :param position: position on element
        :param value: value
        '''

        self.data.append([element, position, value])

    def update_data(self, element, position, value):
        '''
        Updates data to user module.
        If data was not originally there, adds new row.

        :param element: element index
        :param position: position on element
        :param value: value
        '''
        for item in self.data:
            if item[0] == element and item[1] == position:
                item[2] = value
                return

        self.add_data(element, position, value)

    def clear_data(self):
        '''
        Clears data.
        '''
        self.data = []

    def to_gwa(self):
        gwa_list = []
        write_title = [self._module_name + _write_sID(self.sID), self.index, self.name,
                       self.colour, self.axis, self.dir, self.dimension, self.contour, self.is_centre]
        gwa_list.append('\t'.join([str(x) for x in write_title]))

        for item in self.data:
            write_module = ['USER_MOD_ELEM.2', self.index, item[0], item[1], item[2]]
            gwa_list.append('\t'.join([str(x) for x in write_module]))

        return gwa_list

    def __repr__(self):
        return '\n'.join(self.to_gwa())

    def __eq__(self, other):
        return self.__repr__() == other.__repr__()


class UserModuleMember(_ModuleOrdered):
    '''
    Uses USER_MOD_MEMBER_TITLE.2 syntax from GSA 10.1

    User modules for members.

    :param index: index
    :param sID: sID
    :param name: name
    :param colour: colour
    :param axis: axis to display in
    :param dir: diagram direction
    :param dimension: units for module
    :param contour: contour type
    :param data: list of [member, position, value] of user module data

    '''

    _module_name = "USER_MOD_MEMBER_TITLE.2"
    _syntax = "USER_MOD_MEMBER_TITLE.2 | module | name | colour | axis | dir | dimension | blob"
    _attr = ['index', 'name', 'colour', 'axis', 'dir', 'dimension', 'contour']
    _syntax_attr_rename = {
        'index': 'module',
        'contour': 'blob'
    }

    colour_default = Colours.none
    axis_default = UserModuleAxisEnum.GLOBAL
    dir_default = UserModuleEnum.DIR_NONE
    dimension_default = 'NULL'
    contour_default = UserModuleEnum.CONTOUR_BLOB

    data_default = None

    # Order must be index, sID, etc., because this class uses the implicit _from_gwa
    # function to parse gwa records. In _from_gwa, attr_no_default may have an sID, which
    # will then replace the default value set here.
    def __init__(self, index, name, colour=colour_default, axis=axis_default,
                 dir=dir_default, dimension=dimension_default, contour=contour_default,
                 data=data_default, sID=''):
        self.index = index
        self.sID = sID
        self.name = name
        self.colour = colour
        self.axis = axis
        self.dir = dir
        self.dimension = dimension
        self.contour = contour
        if data is None:
            self.data = []
        else:
            self.data = data.copy()

    def add_module(self, member, position, value):
        '''
        Add data to user module.

        :param member: member index
        :param position: position on element
        :param value: value
        '''
        self.data.append([member, position, value])

    def update_module(self, member, position, value):
        '''
        Updates data to user module.
        If data was not originally there, adds new row.

        :param member: member index
        :param position: position on element
        :param value: value
        '''
        for item in self.data:
            if item[0] == member and item[1] == position:
                item[2] = value
                return

        self.add_module(member, position, value)

    def clear_modules(self):
        '''
        Clears data.
        '''
        self.data = []

    def to_gwa(self):
        gwa_list = []
        write_title = [self._module_name + _write_sID(self.sID), self.index, self.name,
                       self.colour, self.axis, self.dir, self.dimension, self.contour]
        gwa_list.append('\t'.join([str(x) for x in write_title]))

        for item in self.data:
            write_module = ['USER_MOD_MEMBER.2', self.index, item[0], item[1], item[2]]
            gwa_list.append('\t'.join([str(x) for x in write_module]))

        return gwa_list

    def __repr__(self):
        return '\n'.join(self.to_gwa())

    def __eq__(self, other):
        return self.__repr__() == other.__repr__()


class UserModuleNode(_ModuleOrdered):
    '''
    Uses USER_MOD_NODE_TITLE.2 syntax for GSA 10.1
    User modules for members.

    :param index: index
    :param sID: sID
    :param name: name
    :param colour: colour
    :param axis: axis to display in
    :param dir: diagram direction
    :param dimension: units for module
    :param data: list of [member, position, value] of user module data
    '''

    _module_name = "USER_MOD_NODE_TITLE.2"
    _syntax = "USER_MOD_NODE_TITLE.2 | module | name | colour | axis | dir | dimension"
    _attr = ['index', 'name', 'colour', 'axis', 'dir', 'dimension']
    _syntax_attr_rename = {'index': 'module', }

    colour_default = Colours.none
    axis_default = UserModuleAxisEnum.GLOBAL
    dir_default = UserModuleEnum.DIR_NONE
    dimension_default = 'NULL'

    data_default = None

    def __init__(self, index, name, colour=colour_default, axis=axis_default,
                 dir=dir_default, dimension=dimension_default,
                 data=data_default, sID=''):
        self.index = index
        self.sID = sID
        self.name = name
        self.colour = colour
        self.axis = axis
        self.dir = dir
        self.dimension = dimension
        if data is None:
            self.data = []
        else:
            self.data = data.copy()

    def add_module(self, node, value):
        '''
        Add data to user module.

        :param node: node index
        :param value: value
        '''
        self.data.append([node, value])

    def update_module(self, node, value):
        '''
        Updates data to user module.
        If data was not originally there, adds new row.

        :param node: node index
        :param value: value
        '''
        for item in self.data:
            if item[0] == node:
                item[1] = value
                return

        self.add_module(node, value)

    def clear_modules(self):
        '''
        Clears data.
        '''
        self.data = []

    def to_gwa(self):
        gwa_list = []
        write_title = [self._module_name + _write_sID(self.sID), self.index, self.name,
                       self.colour, self.axis, self.dir, self.dimension]
        gwa_list.append('\t'.join([str(x) for x in write_title]))

        for item in self.data:
            write_module = ['USER_MOD_NODE.2', self.index, item[0], item[1]]
            gwa_list.append('\t'.join([str(x) for x in write_module]))

        return gwa_list

    def __repr__(self):
        return '\n'.join(self.to_gwa())

    def __eq__(self, other):
        return self.__repr__() == other.__repr__()


'''

ToDo: To be implimented after the new GSA API is released
########################################################################################################################
# Materials
########################################################################################################################

class Material(_ModuleOrdered):

    
class MatCurve(_ModuleOrdered):
    Material Property module (GSA 10.1 MAT_CURVE_PARAM.3 Parameters) 

    :param index: index
    :param name: name
    :param model: Material Model   
                    UNDEF	            undefined
                    MAT_VOID	        void material - no strength
                    EXPLICIT	        explicit material curve
                    EXPLICIT_ENV	    explicit material curve envelope
                    LINEAR              linear material
                    ELAS_PLAS	        elastic-perfectly plastic material
                    ELAS_HARD	        elastic-hardening material
                    NO_COMPRESSION	    no compression
                    PRESTRESS	        prestress tendons
                    PROG_YIELD	        progressive yield
                    BS5400_BAR	        BS 5400 bar curve
                    PARK	            Park model
                    ASTM_STRAND	        ASTM A416 prestress strand
                    ELAS_PLAS_TEN	    elastic-plastic tendon
                    RECT_PARABOLA	    parabola rectangle
                    RECTANGLE	        rectangular compression block
                    BILINEAR	        bilinear stress block
                    POPOVICS	        Popovics
                    FIB_SCHEMATIC	    FIB schematic (BS8110 part2 curve)
                    RECT_AISC	        AISC 360 filled compression tube
                    BS8110_PT2	        part2 curve
                    NO_TENSION	        no tension
                    INTERPOLATED	    interplated between cracked and uncracked
                    TR59	            Technical Report 59 (was ICE technical note 372)
                    PD6687	            PD 6687 variant of Eurocode model
                    EC2_CONFINED	    EC2 confined
                    MANDER	            Mander
                    MANDER_CONFINED	    Mander confined
                    MOD_RECTANGLE	    modified rectangle
                    RIGID_PLAS	        rigid-plastic
    :param strain[6]: [Elastic compression, Elastic tension, Plastic compression, 
                        Plastic tension, Failure compression, Failure tension]
    :param gamma_f: material factor on strength
    :param gamma_e: material factor on elastic modulus
    _module_name = 'MAT_CURVE_PARAM.3'
    name_default = None
    model_default = "UNDEF"
    strains_default = [0, 0, 0, 0, 0, 0]
    gamma_f_default = 0
    gamma_e_default = 0

    def __init__(self, index, name=name_default, model=model_default, strains=strains_default,
                 gamma_f=gamma_f_default, gamma_e=gamma_e_default):
        self.index = index
        self.name = name
        self.model = model
        self.strains = strains
        self.gamma_f = gamma_f
        self.gamma_e = gamma_e

    @classmethod
    def from_gwa(cls, gwa):
        """
        :param gwa:
        :return:
        """
        tokens = deque(gwa)
        index = tokens.popleft()
        name = tokens.popleft()
        model = tokens.popleft()
        strains = [float(tokens.popleft()) for x in range(6)]
        gamma_f = tokens.popleft()
        gamma_e = tokens.popleft()

        return cls(index, name=name, model=model, strains=strains, gamma_f=gamma_f, gamma_e=gamma_e)


    def to_gwa(self):
        """
        :return:
        """
        write = [self._module_name, self.index, self.name, self.model, self.strains, self.gamma_f, self.gamma_e]

        return '\t'.join([str(x) for x in write])
        
'''


########################################################################################################################
# Sections
########################################################################################################################


class Section(_ModuleOrdered):
    '''
    Section module.

    :param index: index
    :param sID: sID
    :param name: name
    :param colour: colour (from gsapy.enum.Colours)
    :param mat: material type (from gsapy.enum.MaterialEnum)
    :param grade: index of design material
    :param anal: index of analysis material, set to 0 to determine from grade
    :param desc: section description string or Profile object
    :param cost: cost per unit mass
    '''
    _module_name = 'PROP_SEC.3'
    _is_super = True
    _syntax = 'PROP_SEC.3 | index | name | colour | mat | grade | anal | desc | cost | ref_point | off_y | off_z '
    _attr = ['num', 'name', 'colour', 'mat', 'grade', 'anal', 'desc', 'cost', 'ref_point', 'off_y', 'off_z']

    name_default = ''
    colour_default = Colours.none
    mat_default = MaterialEnum.GENERIC
    grade_default = 1
    anal_default = 0
    desc_default = 'STD%C%100'
    cost_default = 0
    ref_point_default = ''
    off_y_default = 0
    off_z_default = 0

    def __init__(self, index: int,
                 name: str = name_default,
                 colour: Colours = colour_default,
                 mat: MaterialEnum = mat_default,
                 grade: int = grade_default,
                 anal: int = anal_default,
                 desc: str = desc_default,
                 cost: float = cost_default,
                 ref_point=ref_point_default,
                 off_y=off_y_default,
                 off_z=off_z_default,
                 sID: str = ''):
        self.sID = sID
        self.index = index
        self.name = name
        self.colour = colour
        self.mat = mat
        self.grade = grade
        self.anal = anal
        if isinstance(desc, str):
            self.desc = desc
        else:
            self.profile = desc
        self.cost = cost
        self.ref_point = ref_point
        self.off_y = off_y
        self.off_z = off_z

    @classmethod
    def from_gwa(cls, gwa):
        # PROP_SEC.3 | num | name | colour | mat | grade | anal | desc | cost | ref_point | off_y | off_z

        '''Interprets PROP_SPR gwa line and returns a named tuple of its properties'''
        gwa_error = gwa
        args = {}

        # TODO: PARSE STRING TO ARGUMENTS
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, args['sID'] = _parse_record_sID(record_sID)  # TODO: check and log version of data format?
        args['index'] = int(tokens.popleft())
        args['name'] = sq(tokens.popleft())
        args['colour'] = tokens.popleft()
        args['mat'] = tokens.popleft()
        args['grade'] = tokens.popleft()
        args['anal'] = tokens.popleft()
        args['desc'] = tokens.popleft()
        args['cost'] = tokens.popleft()
        args['ref_point'] = tokens.popleft()
        args['off_y'] = tokens.popleft()
        args['off_z'] = tokens.popleft()

        return cls(**args)

    def to_gwa(self):
        """

        :return:
        """
        write = ["PROP_SEC.3" + _write_sID(self.sID), self.index, self.name, self.colour, self.mat,
                 self.grade, self.anal, self.desc, self.cost, self.ref_point, self.off_y, self.off_z]

        return '\t'.join([str(x) for x in write])

    @property
    def profile(self):
        '''
        Interprets the section description and returns an object of the appropriate submodule.

        :return: Profile submodule object
        '''

        return Profile.from_desc(self.desc)

    @profile.setter
    def profile(self, value):
        '''
        Sets the section description from the Profile submodule object

        :param value: Profile submodule object
        '''

        if issubclass(type(value), Profile):
            self.desc = value.to_desc()
        else:
            raise GSAError('Unable to set profile.')


class Profile:
    '''
    Module to help create section profile descriptions.
    Not to be used by itself.
    '''

    def __init__(self):
        raise GSAError('Profile cannot be used to create section descriptions. ' +
                       'Use a specific sub class (e.g. ProfileRectangular).')

    @classmethod
    def get_type(cls, desc):
        '''
        Extracts the profile type from a section description.

        :param desc: section description
        :return: profile type
        '''

        desc = desc.split('%')
        if desc[0] == SectionTypeEnum.CATALOGUE:
            return SectionTypeEnum.CATALOGUE
        elif desc[0] == SectionTypeEnum.STANDARD:
            return desc[1].replace(")", "(").split("(")[0]
        elif desc[0] == SectionTypeEnum.GEOMETRY:
            return desc[1].replace(")", "(").split("(")[0]

    @classmethod
    def get_unit(cls, desc):
        '''
        Extracts the units from a section description.

        :param desc: section description
        :return: unit string
        '''
        desc = desc.split('%')
        desc = desc[1].replace(")", "(").split("(")
        if len(desc) >= 2:
            return desc[1]
        else:
            return 'mm'
        # TODO: should we have a units enumeration?

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a Profile submodule object

        :param desc: section description
        :return: Profile submodule object
        '''
        type = cls.get_type(desc)

        for submodule in cls.__subclasses__():
            if type == submodule._section_type:
                return submodule.from_desc(desc)

        raise GSAError('Description of type {} could not be parsed.'.format(type))


class ProfileCatalogue(Profile):
    '''
    Catalogue section description module

    :param type: type of section
    :param section: section
    '''

    _section_type = SectionTypeEnum.CATALOGUE
    type_default = ''
    section_default = ''

    def __init__(self, type, section):
        self.type = type
        self.section = section

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileCatalogue object

        :param desc: section description
        :return: ProfileCatalogue object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(desc[1], desc[2])

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [self._section_type, self.type, self.section]
        return '%'.join(str(x) for x in desc)


class ProfileRectangular(Profile):
    '''
    Rectangular section description module

    :param d: depth
    :param h: height
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.RECTANGULAR
    unit_default = 'mm'

    def __init__(self, d, h, unit=unit_default):
        self.d = d
        self.h = h
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileRectangular object

        :param desc: section description
        :return: ProfileRectangular object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = ['STD', self._section_type + "(" + self.unit + ")",
                self.d, self.h]
        return '%'.join(str(x) for x in desc)


class ProfileRectangularHollow(Profile):
    '''
    Hollow rectangular section description module

    :param d: depth
    :param h: height
    :param t_side: side thickness
    :param t_bot: top and bottom thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.RECTANGULAR_HOLLOW
    unit_default = 'mm'

    def __init__(self, d, h, t_side, t_bot, unit=unit_default):
        self.d = d
        self.h = h
        self.t_side = t_side
        self.t_bot = t_bot
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileRectangularHollow object

        :param desc: section description
        :return: ProfileRectangularHollow object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), float(desc[4]), float(desc[5]), unit)

    def to_desc(self):
        """
        Compiles section description

        :return: section description
        """

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.h, self.t_side, self.t_bot]
        return '%'.join(str(x) for x in desc)


class ProfileCircular(Profile):
    '''
    Circular section description module

    :param d: diameter
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.CIRCULAR
    unit_default = 'mm'

    def __init__(self, d, unit=unit_default):
        self.d = d
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileCircular object

        :param desc: section description
        :return: ProfileCircular object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d]
        return '%'.join(str(x) for x in desc)


class ProfileCircularHollow(Profile):
    '''
    Hollow circular section description module

    :param d: depth
    :param t: thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.CIRCULAR_HOLLOW
    unit_default = 'mm'

    def __init__(self, d, t, unit=unit_default):
        self.d = d
        self.t = t
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileCircularHollow object

        :param desc: section description
        :return: ProfileCircularHollow object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.t]
        return '%'.join(str(x) for x in desc)


class ProfileISection(Profile):
    '''
    I section description module

    :param d: depth
    :param w: width
    :param t_flange: flange thickness
    :param t_web: web thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.I_SECTION
    unit_default = 'mm'

    def __init__(self, d, w, t_flange, t_web, unit=unit_default):
        self.d = d
        self.w = w
        self.t_flange = t_flange
        self.t_web = t_web
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileISection object

        :param desc: section description
        :return: ProfileISection object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), float(desc[5]), float(desc[4]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.w, self.t_flange, self.t_web]
        return '%'.join(str(x) for x in desc)


class ProfileTeeSection(Profile):
    '''
    Tee section description module

    :param d: depth
    :param w: width
    :param t_flange: flange thickness
    :param t_web: web thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.TEE_SECTION
    unit_default = 'mm'

    def __init__(self, d, w, t_flange, t_web, unit=unit_default):
        self.d = d
        self.w = w
        self.t_flange = t_flange
        self.t_web = t_web
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileTeeSection object

        :param desc: section description
        :return: ProfileTeeSection object
        '''
        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), float(desc[5]), float(desc[4]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''
        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.w, self.t_flange, self.t_web]
        return '%'.join(str(x) for x in desc)


class ProfileChannel(Profile):
    '''
    Channel section description module

    :param d: depth
    :param w: width
    :param t_flange: flange thickness
    :param t_web: web thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.CHANNEL
    unit_default = 'mm'

    def __init__(self, d, w, t_flange, t_web, unit=unit_default):
        self.d = d
        self.w = w
        self.t_flange = t_flange
        self.t_web = t_web
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileChannel object

        :param desc: section description
        :return: ProfileChannel object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), float(desc[5]), float(desc[4]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.w, self.t_flange, self.t_web]
        return '%'.join(str(x) for x in desc)


class ProfileDoubleChannel(Profile):
    '''
    Double channel section description module

    :param d: depth
    :param w: width
    :param t_flange: flange thickness
    :param t_web: web thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.DOUBLE_CHANNEL
    unit_default = 'mm'

    def __init__(self, d, w, t_flange, t_web, unit=unit_default):
        self.d = d
        self.w = w
        self.t_flange = t_flange
        self.t_web = t_web
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileDoubleChannel object

        :param desc: section description
        :return: ProfileDoubleChannel object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), float(desc[5]), float(desc[4]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.w, self.t_flange, self.t_web]
        return '%'.join(str(x) for x in desc)


class ProfileAngle(Profile):
    '''
    Angle section description module

    :param d: depth
    :param w: width
    :param t_flange: flange thickness
    :param t_web: web thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.ANGLE
    unit_default = 'mm'

    def __init__(self, d, w, t_flange, t_web, unit=unit_default):
        self.d = d
        self.w = w
        self.t_flange = t_flange
        self.t_web = t_web
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileAngle object

        :param desc: section description
        :return: ProfileAngle object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), float(desc[5]), float(desc[4]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.w, self.t_flange, self.t_web]
        return '%'.join(str(x) for x in desc)


class ProfileDoubleAngle(Profile):
    '''
    Double angle section description module

    :param d: depth
    :param w: width
    :param t_flange: flange thickness
    :param t_web: web thickness
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.DOUBLE_ANGLE
    unit_default = 'mm'

    def __init__(self, d, w, t_flange, t_web, unit=unit_default):
        self.d = d
        self.w = w
        self.t_flange = t_flange
        self.t_web = t_web
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileDoubleAngle object

        :param desc: section description
        :return: ProfileDoubleAngle object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        return cls(float(desc[2]), float(desc[3]), float(desc[5]), float(desc[4]), unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.STANDARD, self._section_type + "(" + self.unit + ")",
                self.d, self.w, self.t_flange, self.t_web]
        return '%'.join(str(x) for x in desc)


class ProfilePerimeter(Profile):
    '''
    Perimeter section description module

    :param y: list of y coordinate values
    :param z: list of z coordinate values
    :param unit: unit
    '''

    _section_type = SectionTypeEnum.PERIMETER
    unit_default = 'mm'

    def __init__(self, y, z, unit=unit_default):
        self.y = y
        self.z = z
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfilePerimeter object

        :param desc: section description
        :return: ProfilePerimeter object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        y = []
        z = []
        for d in desc[2:]:
            if d == '[V]':
                break
            d = d.replace(")", "(").split("(")[1].split("|")
            y.append(float(d[0]))
            z.append(float(d[1]))
        return cls(y, z, unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.GEOMETRY, self._section_type + "(" + self.unit + ")"]
        desc += ["M(" + str(self.y[0]) + "|" + str(self.z[0]) + ")"]
        for point in zip(self.y[1:], self.z[1:]):
            desc += ["L(" + str(point[0]) + "|" + str(point[1]) + ")"]
        return '%'.join(str(x) for x in desc)


class ProfileFabricated(Profile):
    '''
    Fabricated section description module

    :param y_start: list of segment starting y coordinates
    :param z_start: list of segment starting z coordinates
    :param y_end: list of segment ending y coordinates
    :param z_end: list of segment ending z coordinates
    :param t: list of segment thickness
    :param unit: unit
    '''
    _section_type = SectionTypeEnum.FABRICATED
    unit_default = 'mm'

    def __init__(self, y_start, z_start, y_end, z_end, t, unit=unit_default):
        self.y_start = y_start
        self.z_start = z_start
        self.y_end = y_end
        self.z_end = z_end
        self.t = t
        self.unit = unit

    @classmethod
    def from_desc(cls, desc):
        '''
        Interprets a section description and returns a ProfileFabricated object

        :param desc: section description
        :return: ProfileFabricated object
        '''

        unit = Profile.get_unit(desc)
        desc = desc.split('%')
        y_start = []
        z_start = []
        y_end = []
        z_end = []
        t = []
        for d in desc[2:]:
            if d == '[V]':
                break
            d = d.replace(")", "(").split("(")[1].split("|")
            y_start.append(float(d[0]))
            z_start.append(float(d[1]))
            y_end.append(float(d[2]))
            z_end.append(float(d[3]))
            t.append(float(d[4]))
        return cls(y_start, z_start, y_end, z_end, t, unit)

    def to_desc(self):
        '''
        Compiles section description

        :return: section description
        '''

        desc = [SectionTypeEnum.GEOMETRY, self._section_type + "(" + self.unit + ")"]
        for segment in zip(self.y_start, self.z_start, self.y_end, self.z_end, self.t):
            desc += ["S(" + '|'.join(str(s) for s in segment) + ")"]
        return '%'.join(str(x) for x in desc)


########################################################################################################################
# Node Properties
########################################################################################################################


class spring_property(_ModuleCollection):
    """
    Spring property module.
    :param num: index
    :param sID: sID
    :param name: name
    :param colour: colour (from gsapy.enum.Colours)
    :param type: type of property

    SPRING: Spring type Property (GeneraL)
    :param curve_x: nonlinear spring curve ref in x direction (if 0, spring in this direction is elastic; default is linear)
    :param stiff_x: stiffness value in x direction
    :param curve_y: nonlinear spring curve ref in y direction (if 0, spring in this direction is elastic; default is linear)
    :param stiff_y: stiffness value in y direction
    :param curve_z: nonlinear spring curve ref in z direction (if 0, spring in this direction is elastic; default is linear)
    :param stiff_z: stiffness value in z direction
    :param curve_xx: nonlinear spring curve ref in xx direction (if 0, spring in this direction is elastic; default is linear)
    :param stiff_xx: stiffness value in xx direction
    :param curve_yy: nonlinear spring curve ref in yy direction (if 0, spring in this direction is elastic; default is linear)
    :param stiff_yy: stiffness value in yy direction
    :param curve_zz: nonlinear spring curve ref in zz direction (if 0, spring in this direction is elastic; default is linear)
    :param stiff_zz: stiffness value in zz direction
    :param damping: spring damping value

    DAMPER: Damper type Property (Doesn't seem to exist within GSA 10.1?)
    :param damping_x: damping value in x direction
    :param damping_y: damping value in y direction
    :param damping_z: damping value in z direction
    :param damping_x: damping value in xx direction
    :param damping_y: damping value in yy direction
    :param damping_z: damping value in zz direction

    MATRIX: Matrix type Property (Matrix)
    :param matrix: spring stiffness matrix
    :param damping: damping values

    FRICTION: Friction type Property (Friction)
    :param stiff_x: stiffness value in x
    :param stiff_y: stiffness value in y
    :param stiff_z: stiffness value in z
    :param friction: friction coefficients
    :param damping: damping values

    type: type of Property (Axial,Torsional, Tension-Only, Compression-Only, Connector, Lockup, Gap, )
    :param stiff_x: stiffness value in x
    :param damping: damping value
    :param +ve_lock_up: Tension/Compression
    :param -ve_lock_up: Tension/Compression

    """
    _module_name = 'PROP_SPR.4'
    _syntax = 'PROP_SPR.4 | num	| name | colour	| type | curve_x | stiff_x | curve_y | stiff_y |' \
              'curve_z | stiff_z | curve_xx | stiff_xx | curve_yy | stiff_yy | curve_zz | stiff_zz |' \
              'damping_x | damping_y | damping_z | damping_xx | damping_yy | damping_zz | matrix | ' \
              'damping | +ve_lock_up | -ve_lock_up | friction'
    _attr = ['num', 'name', 'colour', 'type', 'curve_x', 'stiff_x', 'curve_y', 'stiff_y', 'curve_z', 'stiff_z',
             'curve_xx', 'stiff_xx', 'curve_yy', 'stiff_yy', 'curve_zz', 'stiff_zz',
             'damping_x', 'damping_y', 'damping_z', 'damping_xx', 'damping_yy', 'damping_zz',
             'matrix ', 'damping', '+ve_lock_up', '-ve_lock_up', 'friction']

    num_default = 1
    name_default = ''
    colour_default = Colours.none
    type_default = 'GENERAL'
    curve_x_default = 0
    stiff_x_default = 0
    curve_y_default = 0
    stiff_y_default = 0
    curve_z_default = 0
    stiff_z_default = 0
    curve_xx_default = 0
    stiff_xx_default = 0
    curve_yy_default = 0
    stiff_yy_default = 0
    curve_zz_default = 0
    stiff_zz_default = 0
    damping_x_default = 0
    damping_y_default = 0
    damping_z_default = 0
    damping_xx_default = 0
    damping_yy_default = 0
    damping_zz_default = 0
    matrix_default = 0
    damping_default = 0
    pos_lock_up_default = 0
    neg_lock_up_default = 0
    friction_default = 0

    def __init__(self, sID=None, num=num_default, name=name_default, colour=colour_default, type=type_default,
                 curve_x=curve_x_default, stiff_x=stiff_x_default, curve_y=curve_y_default, stiff_y=stiff_y_default,
                 curve_z=curve_z_default, stiff_z=stiff_z_default, curve_xx=curve_xx_default, stiff_xx=stiff_xx_default,
                 curve_yy=curve_yy_default, stiff_yy=stiff_yy_default, curve_zz=curve_zz_default,
                 stiff_zz=stiff_zz_default,
                 damping_x=damping_x_default, damping_y=damping_y_default, damping_z=damping_z_default,
                 damping_xx=damping_xx_default, damping_yy=damping_yy_default, damping_zz=damping_zz_default,
                 matrix=matrix_default, damping=damping_default, pos_lock_up=pos_lock_up_default,
                 neg_lock_up=neg_lock_up_default, friction=friction_default):
        self.sID = sID
        self.num = num
        self.name = name
        self.colour = colour
        self.type = type
        self.spring = 'SPRING'
        self.curve_x = curve_x
        self.stiff_x = stiff_x
        self.curve_y = curve_y
        self.stiff_y = stiff_y
        self.curve_z = curve_z
        self.stiff_z = stiff_z
        self.curve_xx = curve_xx
        self.stiff_xx = stiff_xx
        self.curve_yy = curve_yy
        self.stiff_yy = stiff_yy
        self.curve_zz = curve_zz
        self.stiff_zz = stiff_zz
        self.damping_x = damping_x
        self.damping_y = damping_y
        self.damping_z = damping_z
        self.damping_xx = damping_xx
        self.damping_yy = damping_yy
        self.damping_zz = damping_zz
        self.matrix = matrix
        self.damping = damping
        self.pos_lock_up = pos_lock_up
        self.neg_lock_up = neg_lock_up
        self.friction = friction

    @classmethod
    def from_gwa(cls, gwa):
        # PROP_SPR.4 | num | name | colour | SPRING | curve_x | stiff_x | curve_y | stiff_y | curve_z | stiff_z |
        # curve_xx | stiff_xx | curve_yy | stiff_yy | curve_zz | stiff_zz | damping
        # PROP_SPR.4 | num | name | colour | DAMPER | damping_x | damping_y | damping_z | damping_xx | damping_yy |
        # damping_zz
        # PROP_SPR.4 | num | name | colour | MATRIX | matrix | damping
        # PROP_SPR.4 | num | name | colour | FRICTION | stiff_x | stiff_y | stiff_z | friction | damping
        # PROP_SPR.4 | num | name | colour | type | stiff_x | damping | +ve_lock_up | -ve_lock_up
        '''Interprets PROP_SPR gwa line and returns a named tuple of its properties'''
        gwa_error = gwa
        args = {}

        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, args['sID'] = _parse_record_sID(record_sID)  # TODO: check and log version of data format?
        args['num'] = int(tokens.popleft())
        args['name'] = sq(tokens.popleft())
        args['colour'] = tokens.popleft()
        args['type'] = tokens.popleft()
        if args['type'] == 'GENERAL':
            args['curve_x'] = float(tokens.popleft())
            args['stiff_x'] = float(tokens.popleft())
            args['curve_y'] = float(tokens.popleft())
            args['stiff_y'] = float(tokens.popleft())
            args['curve_z'] = float(tokens.popleft())
            args['stiff_z'] = float(tokens.popleft())
            args['curve_xx'] = float(tokens.popleft())
            args['stiff_xx'] = float(tokens.popleft())
            args['curve_yy'] = float(tokens.popleft())
            args['stiff_yy'] = float(tokens.popleft())
            args['curve_zz'] = float(tokens.popleft())
            args['stiff_zz'] = float(tokens.popleft())
            args['damping'] = float(tokens.popleft())

        elif args['type'] == 'DAMPER':
            args['damping_x'] = tokens.popleft()
            args['damping_y'] = tokens.popleft()
            args['damping_z'] = tokens.popleft()
            args['damping_xx'] = tokens.popleft()
            args['damping_yy'] = tokens.popleft()
            args['damping_zz'] = tokens.popleft()

        elif args['type'] == 'MATRIX':
            args['matrix'] = tokens.popleft()
            args['damping'] = tokens.popleft()

        elif args['type'] == 'FRICTION':
            args['stiff_x'] = tokens.popleft()
            args['stiff_y'] = tokens.popleft()
            args['stiff_z'] = tokens.popleft()
            args['friction'] = tokens.popleft()
            args['damping'] = tokens.popleft()

        else:
            args['stiff_x'] = tokens.popleft()
            args['damping'] = tokens.popleft()
            args['+ve_lock_up'] = tokens.popleft()
            args['-ve_lock_up'] = tokens.popleft()

        return cls(**args)

    def to_gwa(self):
        """

        :return:
        """
        write = ["PROP_SPR.4" + _write_sID(self.sID), self.num, self.name, self.colour,
                 self.type]
        if self.type == 'GENERAL':
            write += [self.curve_x, self.stiff_x, self.curve_y, self.stiff_y, self.curve_z, self.stiff_z,
                      self.curve_xx, self.stiff_xx, self.curve_yy, self.stiff_yy, self.curve_zz, self.stiff_zz,
                      self.damping]
        elif self.type == 'MATRIX':
            write += [self.matrix, self.damping]
        elif self.type == 'FRICTION':
            write += [self.stiff_x, self.stiff_y, self.stiff_z, self.friction, self.damping]
        else:
            write += [self.stiff_x, self.damping, self.pos_lock_up, self.neg_lock_up]

        return '\t'.join([str(x) for x in write])


class mass_property(_ModuleCollection):
    """
    Mass property module.
    :param num: index
    :param sID: sID
    :param name: name
    :param colour: colour (from gsapy.enum.Colours)
    :param axis: type of property
    :param mass: mass of property
    :param Ixx_default = 0
    :param Iyy_default = 0
    :param Izz_default = 0
    :param Ixy_default = 0
    :param Iyz_default = 0
    :param Izx_default = 0
    :param modification status: boolean if mass has been modified
    :param mod_x: modified x mass
    :param mod_y: modified y mass
    :param mod_z: modified z mass
    """
    _module_name = 'PROP_MASS.3'
    _syntax = 'PROP_MASS.3 | num | name | colour | mass | Ixx | Iyy | Izz | Ixy | Iyz | Izx' \
              'mod{ | mod_x | mod_y | mod_z}'

    _attr = ['num', 'name', 'colour', 'mass', 'Ixx', 'Iyy', 'Izz', 'Ixy', 'Iyz',
             'Izx', 'mod', 'mod_x', 'mod_y', 'mod_z']

    num_default = 1
    name_default = ''
    colour_default = Colours.none
    mass_default = 0
    Ixx_default = 0
    Iyy_default = 0
    Izz_default = 0
    Ixy_default = 0
    Iyz_default = 0
    Izx_default = 0
    mod_default = 'DEF'
    mod_x_default = 0
    mod_y_default = 0
    mod_z_default = 0

    def __init__(self, sID=None, num=num_default, name=name_default, colour=colour_default,
                 mass=mass_default, Ixx=Ixx_default, Iyy=Iyy_default, Izz=Izz_default, Ixy=Ixy_default,
                 Iyz=Iyz_default, Izx=Izx_default, mod=mod_default, mod_x=mod_x_default, mod_y=mod_y_default,
                 mod_z=mod_z_default):
        self.sID = sID
        self.num = num
        self.name = name
        self.colour = colour
        self.mass = mass
        self.Ixx = Ixx
        self.Iyy = Iyy
        self.Izz = Izz
        self.Ixy = Ixy
        self.Iyz = Iyz
        self.Izx = Izx
        self.mod = mod
        self.mod_x = mod_x
        self.mod_y = mod_y
        self.mod_z = mod_z

    @classmethod
    def from_gwa(cls, gwa):
        # PROP_MASS.3 | num | name | colour | mass | Ixx | Iyy | Izz | Ixy | Iyz | Izx'
        # mod{ | mod_x | mod_y | mod_z}
        '''Interprets PROP_MASS.3 gwa line and returns a named tuple of its properties'''
        gwa_error = gwa
        args = {}

        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, args['sID'] = _parse_record_sID(record_sID)  # TODO: check and log version of data format?
        args['num'] = int(tokens.popleft())
        args['name'] = sq(tokens.popleft())
        args['colour'] = tokens.popleft()
        args['mass'] = tokens.popleft()
        args['Ixx'] = tokens.popleft()
        args['Iyy'] = tokens.popleft()
        args['Izz'] = tokens.popleft()
        args['Ixy'] = tokens.popleft()
        args['Iyz'] = tokens.popleft()
        args['Izx'] = tokens.popleft()
        args['mod'] = tokens.popleft()

        if args['mod'] == 'MOD':
            args['mod_x'] = tokens.popleft()
            args['mod_y'] = tokens.popleft()
            args['mod_z'] = tokens.popleft()

        return cls(**args)

    def to_gwa(self):
        """

        :return:
        """
        write = ["PROP_MASS.3" + _write_sID(self.sID), self.num, self.name, self.colour,
                 self.mass, self.Ixx, self.Iyy, self.Izz, self.Ixy, self.Iyz, self.Izx, self.mod]
        if self.mod == 'MOD':
            write += [self.mod_x, self.mod_y, self.mod_z]

        return '\t'.join([str(x) for x in write])


class damper_property(_ModuleCollection):
    """
    damper property module.

    :param num: index
    :param name: name
    :param colour: colour (from gsapy.enum.Colours)
    :param type: TRAN: transitional (1 dof),
        ROTN: rotational (1 dof),
        GENERAL: general
    :param damp_x: damping value in x direction
    :param damp_y: damping value in y direction
    :param damp_z: damping value in z direction
    :param damp_xx: damping value in xx direction
    :param damp_yy: damping value in yy direction
    :param damp_zz: damping value in zz direction
    """
    _module_name = 'PROP_DAMP.2'
    _syntax = 'PROP_DAMP.2 | num | name | colour | type | damp_x | damp_y | damp_z | damp_xx | damp_yy | damp_zz'

    _attr = ['num', 'name', 'colour', 'type', 'damp_x', 'damp_y', 'damp_z', 'damp_xx', 'damp_yy', 'damp_zz']

    num_default = 1
    name_default = ''
    colour_default = Colours.none
    type_default = 'GENERAL'
    damp_x_default = 0
    damp_y_default = 0
    damp_z_default = 0
    damp_xx_default = 0
    damp_yy_default = 0
    damp_zz_default = 0

    def __init__(self, sID=None, num=num_default, name=name_default, colour=colour_default, type=type_default,
                 damp_x=damp_x_default, damp_y=damp_y_default, damp_z=damp_z_default, damp_xx=damp_xx_default,
                 damp_yy=damp_yy_default, damp_zz=damp_zz_default):
        self.sID = sID
        self.num = num
        self.name = name
        self.colour = colour
        self.type = type
        self.damp_x = damp_x
        self.damp_y = damp_y
        self.damp_z = damp_z
        self.damp_xx = damp_xx
        self.damp_yy = damp_yy
        self.damp_zz = damp_zz

    @classmethod
    def from_gwa(cls, gwa):
        # PROP_DAMP.2 | num | name | colour | type | damp_x | damp_y | damp_z | damp_xx | damp_yy | damp_zz'

        '''Interprets PROP_DAMP.2 gwa line and returns a named tuple of its properties'''
        gwa_error = gwa
        args = {}

        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, args['sID'] = _parse_record_sID(record_sID)
        args['num'] = int(tokens.popleft())
        args['name'] = sq(tokens.popleft())
        args['colour'] = tokens.popleft()
        args['type'] = tokens.popleft()
        args['damp_x'] = tokens.popleft()
        args['damp_y'] = tokens.popleft()
        args['damp_z'] = tokens.popleft()
        args['damp_xx'] = tokens.popleft()
        args['damp_yy'] = tokens.popleft()
        args['damp_zz'] = tokens.popleft()

        return cls(**args)

    def to_gwa(self):
        """

        :return:
        """
        write = ["PROP_DAMP.2 " + _write_sID(self.sID), self.num, self.name, self.colour, self.type,
                 self.damp_x, self.damp_y, self.damp_z, self.damp_xx, self.damp_yy, self.damp_zz]

        return '\t'.join([str(x) for x in write])


########################################################################################################################
# Analysis Tasks
########################################################################################################################


class AnalysisCase(_ModuleOrdered):
    '''
    Analysis case module.

    :param index: index of analysis case record
    :param name: case name
    :param task: task number
    :param description: load description (e.g. "1.4L1+1.2L2")
    :param sID: sID
    '''

    _module_name = 'ANAL.1'
    _syntax = 'ANAL | case | name | task | desc'
    _attr = ['index', 'name', 'task', 'description']
    _syntax_attr_rename = {
        'index': 'case',
        'description': 'desc'}

    def __init__(self, index, name, task, description, sID=''):
        # def __init__(self, index, sID='', name='', task=None, description=None):
        self.index = index
        self.sID = sID
        self.name = name
        self.task = task
        self.description = description


class AnalysisTask(_ModuleOrdered):
    '''
    AnalysisTask base module.
    Cannot be used to initiate analysis task records.
    '''
    _module_name = 'TASK.1'
    _is_super = True

    def __init__(self):
        raise GSAError('AnalysisTask cannot be used to instantiate analysis task records.')

    @classmethod
    def from_gwa(cls, gwa):
        """
        Interprets TASK gwa record and returns an object of the appropriate submodule.

        :param gwa: GWA record separated into a list
        :return: AnalysisTask submodule object
        """
        module_name, _ = _parse_record_sID(gwa[0])

        # check if it's an analysis task
        if cls._module_name[0:5] == module_name[
                                    0:5]:  ## GSA is sometimes returning TASK.1 and TASK.2 from the same model
            # match solver type
            solver = [gwa[4], gwa[5]]
            for submodule in cls.__subclasses__():
                if module_name == "TASK.1":
                    if submodule._solver in solver:
                        return submodule.from_gwa(gwa)
                else:
                    return Task2.from_gwa(gwa)

        # return nothing if its (i.e., GSSPARAM, TASK_TAG)


class Task2(AnalysisTask):
    '''
    Updated class for the Task.2 keyword. All tasks use this, instead of separate TASK classes

    TASK.2 Syntax

    :param index: index
    :param name: task name
    :param stage: analysis stage
    :param GSS: GSS solver
    :param Solution: solution type:
                UNDEF (no solution specified),
                STATIC,
                MODAL,
                RITZ,
                BUCKLING,
                STATIC\_P\_DELTA,
                MODAL\_P\_DELTA,
                RITZ\_P\_DELTA,
                MASS,
                STABILITY,
                STABILITY\_P\_DELTA,
                STATIC\_NL\_P\_DELTA (used internally only),
                BUCKLING\_NL,
                INFLUENCE (used internally in bridge analysis)
    :param mode\_1: number of high modes + start mode
    :param mode\_2: number of low modes + number of modes
    :param num\_iter: number of iterations
    :param p\_delta:
                DEFINE: one p-delta case used for all analysis cases,
                SELF: each analysis case defines its own p-delta case,
                An: analysis case n provides the p-delta effects,
                Cn: combination case n provides the p-delta effects
    :param p\_delta\_case: P-delta case description
    :param prestress: prestress case description
    :param result: results to be stored - a string where the letters have the following meaning
                D: displacements,
                V: velocities,
                A: accelerations,
                R: reactions,
                C: constraints,
                M: mass,
                E: element displacements,
                F: forces and moments,
                N: 2D forces N & Q and moments M,
                S: 2D stresses,
                U: strain energy,
                T: total loads and total reactions,
                \*: values at centre only for 2D results
    :param prune: pruning of influence results (bridge analysis)
                INFL: prune influence results,
                NONE: no pruning of results
    :param geometry: 2D element geometry checks
                ERROR: treat geometry check failures as errors,
                SEVERE: treat geometry check failures as severe warnings
    :param lower: lower cut-off (frequency or load factor)
                NONE: none set,
                value: cut-off value
    :param upper: upper cut-off (frequency or load factor)
                NONE: none set,
                value: cut-off value
    :param raft: this uses enhanced precision for a raft analysis
                RAFT\_HI: use high precision for raft analysis,
                RAFT\_LO: use low (normal) precision for raft analysis
    :param residual: save residual to file
                RESID\_NO: don't save,
                RESID\_NOCONV: save if not converged,
                RESID\_YES: always save
    :param shift: shift applied in eigensolver
    :param stiff: stiffness factor
    :param mass_filter: effective mass ratio for filtering modes
    :param max_cycle: maximum number of cycles for iterative solutions
    '''

    _solver = AnalysisSolverEnum.GSS
    _module_name = 'TASK.2'

    # Defaults...
    stage_default = 0
    solution_default = GSSTypeEnum.STATIC
    mode_1_default = 0
    mode_2_default = 0
    num_iter_default = 0
    p_delta_default = GSSOptionsEnum.P_DELTA_PER_CASE
    p_delta_case_default = None
    prestress_default = None
    result_output_default = [
        AnalysisResultOutputEnum.NODE_DISPLACEMENTS,
        AnalysisResultOutputEnum.VELOCITY,
        AnalysisResultOutputEnum.ACCELERATION,
        AnalysisResultOutputEnum.REACTIONS,
        AnalysisResultOutputEnum.CONSTRAINT_FORCES,
        AnalysisResultOutputEnum.MASS,
        AnalysisResultOutputEnum.ELEMENT_DISPLACEMENTS,
        AnalysisResultOutputEnum.FORCES_AND_MOMENTS,
        AnalysisResultOutputEnum.ELEMENT_FORCES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_3D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_3D,
        AnalysisResultOutputEnum.STRAIN_ENERGY_DENSITY,
        AnalysisResultOutputEnum.VALUE_AT_2D_CENTRE_ONLY
    ]
    prune_default = False
    geometry_check_default = GSSOptionsEnum.GEOMETRY_CHECK_FATAL
    lower_cutoff_default = None
    upper_cutoff_default = None
    raft_precision_default = GSSOptionsEnum.RAFT_PRECISION_LOW
    save_residual_default = GSSOptionsEnum.RESIDUAL_NO_SAVE
    shift_default = 0
    stiffness_factor_default = 1
    mass_filter_default = 0
    max_cycle_default = 1000000

    def __init__(self, index, name, stage=stage_default, solution=solution_default,
                 mode_1=mode_1_default, mode_2=mode_2_default, num_iter=num_iter_default,
                 p_delta=p_delta_default, p_delta_case=p_delta_case_default, prestress=prestress_default,
                 result_output=result_output_default, prune=prune_default,
                 geometry_check=geometry_check_default, lower_cutoff=lower_cutoff_default,
                 upper_cutoff=upper_cutoff_default, raft_precision=raft_precision_default,
                 save_residual=save_residual_default, shift=shift_default,
                 stiffness_factor=stiffness_factor_default, mass_filter=mass_filter_default,
                 max_cycle=max_cycle_default, sID=None):
        self.index = index
        self.sID = sID
        self.name = name
        self.stage = stage
        self.solution = solution
        self.mode_1 = mode_1
        self.mode_2 = mode_2
        self.num_iter = num_iter
        self.p_delta = p_delta
        self.p_delta_case = p_delta_case
        self.prestress = prestress
        self.result_output = result_output
        self.prune = prune
        self.geometry_check = geometry_check
        self.lower_cutoff = lower_cutoff
        self.upper_cutoff = upper_cutoff
        self.raft_precision = raft_precision
        self.save_residual = save_residual
        self.shift = shift
        self.stiffness_factor = stiffness_factor
        self.mass_filter = mass_filter
        self.max_cycle = max_cycle

    @classmethod
    def from_gwa(cls, gwa):
        '''
        Interprets TASK gwa record and returns an AnalysisTaskGSS object.

        :param gwa: GWA record seperated into a list
        :return: AnalysisTaskGSS object
        '''

        # Uses GSA 10.1 syntax
        # TASK.2 | task | name | stage | GSS | solution | mode_1 | mode_2 | num_iter | p_delta |
        # p_delta_case | prestress | result | prune | geometry | lower | upper | raft | residual | shift | stiff |
        # mass_filter | max cycle

        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = tokens.popleft()
        stage = int(tokens.popleft())
        tokens.popleft()  # GSS
        solution = tokens.popleft()
        mode_1 = int(tokens.popleft())
        mode_2 = int(tokens.popleft())
        num_iter = int(tokens.popleft())
        p_delta = tokens.popleft()
        p_delta_case = tokens.popleft()
        if p_delta_case == "none":
            p_delta_case = None
        prestress = tokens.popleft()
        if prestress == "none":
            prestress = None
        result_output = list(tokens.popleft())
        prune = tokens.popleft() == "INFL"
        geometry_check = tokens.popleft()
        lower_cutoff = tokens.popleft()
        lower_cutoff = None if lower_cutoff == "NONE" else float(lower_cutoff)
        upper_cutoff = tokens.popleft()
        upper_cutoff = None if upper_cutoff == "NONE" else float(upper_cutoff)
        raft_precision = tokens.popleft()
        save_residual = tokens.popleft()
        shift = float(tokens.popleft())
        stiffness_factor = float(tokens.popleft())
        mass_filter = int(tokens.popleft())
        max_cycle = int(tokens.popleft())

        return cls(index=index, sID=sID, name=name, stage=stage, solution=solution,
                   mode_1=mode_1, mode_2=mode_2, num_iter=num_iter,
                   p_delta=p_delta, p_delta_case=p_delta_case, prestress=prestress,
                   result_output=result_output, prune=prune,
                   geometry_check=geometry_check, lower_cutoff=lower_cutoff,
                   upper_cutoff=upper_cutoff, raft_precision=raft_precision,
                   save_residual=save_residual, shift=shift,
                   stiffness_factor=stiffness_factor, mass_filter=mass_filter, max_cycle = max_cycle)

    def to_gwa(self):
        '''
        Compiles TASK gwa record.

        :return: TASK gwa record
        '''
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.stage, "GSS",
                 self.solution, self.mode_1, self.mode_2, self.num_iter, self.p_delta]
        write += ['none' if self.p_delta_case is None else self.p_delta_case]
        write += ['none' if self.prestress is None else self.prestress]
        write += [''.join(self.result_output)]
        write += ["INFL" if self.prune else "NONE"]
        write += [self.geometry_check]
        write += ["NONE" if self.lower_cutoff is None else self.lower_cutoff]
        write += ["NONE" if self.upper_cutoff is None else self.upper_cutoff]
        write += [self.raft_precision, self.save_residual, self.shift, self.stiffness_factor, self.mass_filter, self.max_cycle]

        return '\t'.join([str(x) for x in write])


class AnalysisTaskGSS(AnalysisTask):
    '''
    Analysis task module using GSS solver.
    Performs: static, modal, ritz, buckling, static P-delta, modal P-delta, ritz P-delta, mass, model stability, and model stability P-delta analysis

    :param index: index
    :param name: task name
    :param stage: analysis stage, set to 0 to analyse whole model
    :param solution: solution type
    :param mode_1: number of high modes or starting mode
    :param mode_2: number of low modes or number of modes
    :param num_iter: number of iterations
    :param p_delta: static p-delta option
    :param p_delta_case: p-delta case description
    :param prestress: prestress case description
    :param result_output: a list of AnalysisResultOutputEnum indicating results to be stored
    :param front_option: front order option
    :param front_vector: a list of X, Y, and Z components of the front vector. Set as None to define the front vector automatically
    :param prune: prune analysis result
    :param geometry_check: how to treat 2D element geometry checks
    :param lower_cutoff: lower cut-off of frequency or load factor
    :param upper_cutoff: upper cut-off of frequency or load factor
    :param raft_precision: raft precision option
    :param save_residual: residual saving option
    :param shift: shift applied in eigensolver
    :param stiffness_factor: stiffness factor
    :param sID: sID
    '''
    _solver = AnalysisSolverEnum.GSS
    _module_name = 'TASK.1'

    # Defaults...
    stage_default = 0
    solution_default = GSSTypeEnum.STATIC
    mode_1_default = 0
    mode_2_default = 0
    num_iter_default = 0
    p_delta_default = GSSOptionsEnum.P_DELTA_PER_CASE
    p_delta_case_default = None
    prestress_default = None
    result_output_default = [
        AnalysisResultOutputEnum.NODE_DISPLACEMENTS,
        AnalysisResultOutputEnum.VELOCITY,
        AnalysisResultOutputEnum.ACCELERATION,
        AnalysisResultOutputEnum.REACTIONS,
        AnalysisResultOutputEnum.CONSTRAINT_FORCES,
        AnalysisResultOutputEnum.MASS,
        AnalysisResultOutputEnum.ELEMENT_DISPLACEMENTS,
        AnalysisResultOutputEnum.FORCES_AND_MOMENTS,
        AnalysisResultOutputEnum.ELEMENT_FORCES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_3D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_3D,
        AnalysisResultOutputEnum.STRAIN_ENERGY_DENSITY,
        AnalysisResultOutputEnum.VALUE_AT_2D_CENTRE_ONLY
    ]
    front_option_default = GSSOptionsEnum.FRONT_ORDER_MIN
    front_vector_default = None
    prune_default = False
    geometry_check_default = GSSOptionsEnum.GEOMETRY_CHECK_FATAL
    lower_cutoff_default = None
    upper_cutoff_default = None
    raft_precision_default = GSSOptionsEnum.RAFT_PRECISION_LOW
    save_residual_default = GSSOptionsEnum.RESIDUAL_NO_SAVE
    shift_default = 0
    stiffness_factor_default = 1

    def __init__(self, index, name, stage=stage_default, solution=solution_default,
                 mode_1=mode_1_default, mode_2=mode_2_default, num_iter=num_iter_default,
                 p_delta=p_delta_default, p_delta_case=p_delta_case_default, prestress=prestress_default,
                 result_output=result_output_default, front_option=front_option_default,
                 front_vector=front_vector_default, prune=prune_default,
                 geometry_check=geometry_check_default, lower_cutoff=lower_cutoff_default,
                 upper_cutoff=upper_cutoff_default, raft_precision=raft_precision_default,
                 save_residual=save_residual_default, shift=shift_default,
                 stiffness_factor=stiffness_factor_default, sID=None):
        self.index = index
        self.sID = sID
        self.name = name
        self.stage = stage
        self.solution = solution
        self.mode_1 = mode_1
        self.mode_2 = mode_2
        self.num_iter = num_iter
        self.p_delta = p_delta
        self.p_delta_case = p_delta_case
        self.prestress = prestress
        self.result_output = result_output
        self.front_option = front_option
        self.front_vector = front_vector
        self.prune = prune
        self.geometry_check = geometry_check
        self.lower_cutoff = lower_cutoff
        self.upper_cutoff = upper_cutoff
        self.raft_precision = raft_precision
        self.save_residual = save_residual
        self.shift = shift
        self.stiffness_factor = stiffness_factor

    @classmethod
    def from_gwa(cls, gwa):
        '''
        Interprets TASK gwa record and returns an AnalysisTaskGSS object.

        :param gwa: GWA record separated into a list
        :return: AnalysisTaskGSS object
        '''

        # Uses GSA 10.1 syntax
        # TASK | task | name | stage | GSS | solution | mode_1 | mode_2 | num_iter | p_delta |
        # p_delta_case | prestress | result | front_op | vector | x | y | z | prune | geometry |
        # lower | upper | raft | residual | shift | stiff | effmass_filter

        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = tokens.popleft()
        stage = int(tokens.popleft())
        tokens.popleft()  # GSS
        solution = tokens.popleft()
        mode_1 = int(tokens.popleft())
        mode_2 = int(tokens.popleft())
        num_iter = int(tokens.popleft())
        p_delta = tokens.popleft()
        p_delta_case = tokens.popleft()
        if p_delta_case == "none":
            p_delta_case = None
        prestress = tokens.popleft()
        if prestress == "none":
            prestress = None
        result_output = list(tokens.popleft())
        front_option = tokens.popleft()
        front_vector_type = tokens.popleft()
        front_vector = [tokens.popleft() for x in range(3)]
        front_vector = None if front_vector_type == "AUTO" else front_vector
        prune = tokens.popleft() == "INFL"
        geometry_check = tokens.popleft()
        lower_cutoff = tokens.popleft()
        lower_cutoff = None if lower_cutoff == "NONE" else float(lower_cutoff)
        upper_cutoff = tokens.popleft()
        upper_cutoff = None if upper_cutoff == "NONE" else float(upper_cutoff)
        raft_precision = tokens.popleft()
        save_residual = tokens.popleft()
        shift = float(tokens.popleft())
        stiffness_factor = float(tokens.popleft())

        return cls(index=index, sID=sID, name=name, stage=stage, solution=solution,
                   mode_1=mode_1, mode_2=mode_2, num_iter=num_iter,
                   p_delta=p_delta, p_delta_case=p_delta_case, prestress=prestress,
                   result_output=result_output, front_option=front_option,
                   front_vector=front_vector, prune=prune,
                   geometry_check=geometry_check, lower_cutoff=lower_cutoff,
                   upper_cutoff=upper_cutoff, raft_precision=raft_precision,
                   save_residual=save_residual, shift=shift,
                   stiffness_factor=stiffness_factor)

    def to_gwa(self):
        '''
        Compiles TASK gwa record.

        :return: TASK gwa record
        '''
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.stage, "GSS",
                 self.solution, self.mode_1, self.mode_2, self.num_iter, self.p_delta]
        write += ['none' if self.p_delta_case is None else self.p_delta_case]
        write += ['none' if self.prestress is None else self.prestress]
        write += [''.join(self.result_output)]
        write += [self.front_option]
        if self.front_vector is None:
            write += ["AUTO"]
            write += [0, 0, 0]
        else:
            write += ["USER"]
            write += self.front_vector
        write += ["INFL" if self.prune else "NONE"]
        write += [self.geometry_check]
        write += ["NONE" if self.lower_cutoff is None else self.lower_cutoff]
        write += ["NONE" if self.upper_cutoff is None else self.upper_cutoff]
        write += [self.raft_precision, self.save_residual, self.shift, self.stiffness_factor]

        return '\t'.join([str(x) for x in write])


class AnalysisTaskGSRelax(AnalysisTask):
    '''
    Analysis task module using GSRelax solver.
    Performs: non-linear static, form-finding, and component buckling analysis

    :param index: index
    :param name: task name
    :param stage: analysis stage, set to 0 to analyse whole model
    :param solution: solution type
    :param scheme: load scheme
    :param beam_geom_stiffness: consider beam geometric stiffness
    :param shell_geom_stiffness: consider shell geometric stiffness
    :param first_load_increment: first load increment percentage
    :param min_load_increment: minimum load increment percentage
    :param max_load_increment: maximum load increment percentage
    :param termination_control: termination condition
    :param termination_value: maximum number of cycles or maximum minutes to be run
    :param residual_control: relative or absolute residual
    :param force_residual: force residual value
    :param moment_residual: moment residual value
    :param disp_control: displacement controlled
    :param disp_control_node: node where displacement control is checked
    :param disp_control_dir: direction of the displacement control
    :param disp_control_limit: limiting displacement value
    :param load_control: load controlled
    :param load_control_factor: control load factor
    :param element_list: element list, used by component buckling analysis
    :param report_cycle: number of cycles between progress dialog box updates
    :param graphic_cycle: number of cycles between graphic updates
    :param save_residual: residual saving option
    :param damping_type: type of damping
    :param percent_damp_disp: percentage of damping for displacement
    :param percent_damp_rotn: percentage of damping for rotation
    :param dummy_mass_factor: dummy mass factor
    :param dummy_inertia_factor: dummy inertia factor
    :param dummy_mass_power: dummy mass power
    :param dummy_inertia_power: dummy inertia power
    :param auto_dummy_mass: automatic dummy mass option
    :param auto_damping: automatic damping option
    :param save_elem_load: save element force as load after form-finding
    :param save_spacer_load: save spacer force as load after form-finding
    :param show_progress: ... #Confirm with GSA
    :param show_graphic: ... #Confirm with GSA
    :param result_output: a list of AnalysisResultOutputEnum indicating results to be stored
    :param sID: sID
    '''
    _solver = AnalysisSolverEnum.GSRELAX
    _module_name = 'TASK.1'

    # Defaults...
    stage_default = 0
    solution_default = GsRelaxTypeEnum.NONLINEAR_STATIC
    scheme_default = GSRelaxOptionsEnum.LOAD_SCHEME_SINGLE
    num_case_default = 0  # this is always set to 0 as GSA will automatically fill this
    beam_geom_stiffness_default = True
    shell_geom_stiffness_default = False
    first_load_increment_default = 0.1
    min_load_increment_default = 0.0001
    max_load_increment_default = 0.1
    termination_control_default = GSRelaxOptionsEnum.TERMINATION_CONTROL_CYCLE
    termination_value_default = 100000
    residual_control_default = GSRelaxOptionsEnum.RESIDUAL_CONTROL_RELATIVE
    force_residual_default = 0.00100000004750
    moment_residual_default = 0.00100000004750
    disp_control_default = True
    disp_control_node_default = 0
    disp_control_dir_default = 1
    disp_control_limit_default = 0.01
    load_control_default = False
    load_control_factor_default = 1
    element_list_default = None
    analysis_case_list_default = []  # this is always set to empty as GSA will automatically fill this
    report_cycle_default = 10
    graphic_cycle_default = 100
    save_residual_default = GSRelaxOptionsEnum.RESIDUAL_SAVE_IF_NOCONV
    damping_type_default = GSRelaxOptionsEnum.DAMPING_TYPE_VISCOUS
    percent_damp_disp_default = 0
    percent_damp_rotn_default = 0
    dummy_mass_factor_default = 1
    dummy_inertia_factor_default = 1
    dummy_mass_power_default = 1  # non-existant in gwa keywords but does exist in gwa records
    dummy_inertia_power_default = 1  # non-existant in gwa keywords but does exist in gwa records
    auto_dummy_mass_default = True
    auto_damping_default = True
    save_elem_load_default = True
    save_spacer_load_default = GSRelaxOptionsEnum.SAVE_SPACER_LOAD_TO_ELEM
    show_progress_default = GSRelaxOptionsEnum.SHOW_PROGRESS_NONE
    show_graphic_default = GSRelaxOptionsEnum.SHOW_GRAPHIC_NO
    result_output_default = [
        AnalysisResultOutputEnum.NODE_DISPLACEMENTS,
        AnalysisResultOutputEnum.VELOCITY,
        AnalysisResultOutputEnum.ACCELERATION,
        AnalysisResultOutputEnum.REACTIONS,
        AnalysisResultOutputEnum.CONSTRAINT_FORCES,
        AnalysisResultOutputEnum.MASS,
        AnalysisResultOutputEnum.ELEMENT_DISPLACEMENTS,
        AnalysisResultOutputEnum.FORCES_AND_MOMENTS,
        AnalysisResultOutputEnum.ELEMENT_FORCES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_3D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_3D,
        AnalysisResultOutputEnum.STRAIN_ENERGY_DENSITY,
        AnalysisResultOutputEnum.VALUE_AT_2D_CENTRE_ONLY
    ]

    def __init__(self, index, name, stage=stage_default, solution=solution_default,
                 scheme=scheme_default, beam_geom_stiffness=beam_geom_stiffness_default,
                 shell_geom_stiffness=shell_geom_stiffness_default, first_load_increment=first_load_increment_default,
                 min_load_increment=min_load_increment_default, max_load_increment=max_load_increment_default,
                 termination_control=termination_control_default, termination_value=termination_value_default,
                 residual_control=residual_control_default, force_residual=force_residual_default,
                 moment_residual=moment_residual_default, disp_control=disp_control_default,
                 disp_control_node=disp_control_node_default, disp_control_dir=disp_control_dir_default,
                 disp_control_limit=disp_control_limit_default, load_control=load_control_default,
                 load_control_factor=load_control_factor_default, element_list=element_list_default,
                 report_cycle=report_cycle_default, graphic_cycle=graphic_cycle_default,
                 save_residual=save_residual_default, damping_type=damping_type_default,
                 percent_damp_disp=percent_damp_disp_default, percent_damp_rotn=percent_damp_rotn_default,
                 dummy_mass_factor=dummy_mass_factor_default, dummy_inertia_factor=dummy_inertia_factor_default,
                 dummy_mass_power=dummy_mass_power_default, dummy_inertia_power=dummy_inertia_power_default,
                 auto_dummy_mass=auto_dummy_mass_default, auto_damping=auto_damping_default,
                 save_elem_load=save_elem_load_default, save_spacer_load=save_spacer_load_default,
                 show_progress=show_progress_default, show_graphic=show_graphic_default,
                 result_output=result_output_default, sID=None):

        self.index = index
        self.sID = sID
        self.name = name
        self.stage = stage
        self.solution = solution
        self.scheme = scheme
        self.beam_geom_stiffness = beam_geom_stiffness
        self.shell_geom_stiffness = shell_geom_stiffness
        self.first_load_increment = first_load_increment
        self.min_load_increment = min_load_increment
        self.max_load_increment = max_load_increment
        self.termination_control = termination_control
        self.termination_value = termination_value
        self.residual_control = residual_control
        self.force_residual = force_residual
        self.moment_residual = moment_residual
        self.disp_control = disp_control
        self.disp_control_node = disp_control_node
        self.disp_control_dir = disp_control_dir
        self.disp_control_limit = disp_control_limit
        self.load_control = load_control
        self.load_control_factor = load_control_factor
        self.element_list = element_list
        self.report_cycle = report_cycle
        self.graphic_cycle = graphic_cycle
        self.save_residual = save_residual
        self.damping_type = damping_type
        self.percent_damp_disp = percent_damp_disp
        self.percent_damp_rotn = percent_damp_rotn
        self.dummy_mass_factor = dummy_mass_factor
        self.dummy_inertia_factor = dummy_inertia_factor
        self.dummy_mass_power = dummy_mass_power
        self.dummy_inertia_power = dummy_inertia_power
        self.auto_dummy_mass = auto_dummy_mass
        self.auto_damping = auto_damping
        self.save_elem_load = save_elem_load
        self.save_spacer_load = save_spacer_load
        self.show_progress = show_progress
        self.show_graphic = show_graphic
        self.result_output = result_output

    @classmethod
    def from_gwa(cls, gwa):
        '''
        Interprets TASK gwa record and returns an AnalysisTaskGSRelax object.

        :param gwa: GWA record seperated into a list
        :return: AnalysisTaskGSRelax object
        '''

        # TASK | task | name | stage | GSRELAX | solution | scheme | num_case | beam_geo |
        # shell_geo | first_inc | min_inc | max_inc | cycle | num_cycle | rel_abs_residual |
        # force_residual | moment_residual | disp_ctrl | disp_ctrl_node | disp_ctrl_dir |
        # disp_ctrl_value | load_ctrl | ctrl_load_factor | elem_list | anal_cases_list |
        # report_cycle | graphic_cycle | save_residual | damping_type | percent_damp_disp |
        # percent_damp_rotn | dummy_mass_factor | dummy_inertia_factor | dummy_mass_power |
        # dummy_inertia_power | auto_dummy_mass | auto_damping | save_elem_load |
        # save_spacer_load | show_progress | show_graphic | result

        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = tokens.popleft()
        stage = int(tokens.popleft())
        tokens.popleft()  # GSRELAX
        solution = tokens.popleft()
        scheme = tokens.popleft()
        num_case = int(tokens.popleft())  # ignore as GSA will take care of it
        beam_geom_stiffness = tokens.popleft() == 'BEAM_GEO_YES'
        shell_geom_stiffness = tokens.popleft() == 'SHELL_GEO_YES'
        first_load_increment = float(tokens.popleft())
        min_load_increment = float(tokens.popleft())
        max_load_increment = float(tokens.popleft())
        termination_control = tokens.popleft()
        termination_value = int(tokens.popleft())
        residual_control = tokens.popleft()
        force_residual = float(tokens.popleft())
        moment_residual = float(tokens.popleft())
        disp_control = tokens.popleft() == 'DISP_CTRL_YES'
        disp_control_node = int(tokens.popleft())
        disp_control_dir = int(tokens.popleft())
        disp_control_limit = float(tokens.popleft())
        load_control = tokens.popleft() == 'LOAD_CTRL_YES'
        load_control_factor = float(tokens.popleft())
        element_list = cls.list_from_gwa(tokens.popleft())
        for x in range(num_case):
            tokens.popleft()  # ignore as GSA will take care of it
        report_cycle = int(tokens.popleft())
        graphic_cycle = int(tokens.popleft())
        save_residual = tokens.popleft()
        damping_type = tokens.popleft()
        percent_damp_disp = float(tokens.popleft())
        percent_damp_rotn = float(tokens.popleft())
        dummy_mass_factor = float(tokens.popleft())
        dummy_inertia_factor = float(tokens.popleft())
        dummy_mass_power = float(tokens.popleft())
        dummy_inertia_power = float(tokens.popleft())
        auto_dummy_mass = tokens.popleft() == 'AUTO_MASS_YES'
        auto_damping = tokens.popleft() == 'AUTO_DAMP_YES'
        save_elem_load = tokens.popleft() == 'FF_SAVE_ELEM_FORCE_YES'
        save_spacer_load = tokens.popleft()
        show_progress = tokens.popleft()
        show_graphic = tokens.popleft()
        result_output = list(tokens.popleft())

        return cls(index=index, sID=sID, name=name, stage=stage, solution=solution,
                   scheme=scheme, beam_geom_stiffness=beam_geom_stiffness,
                   shell_geom_stiffness=shell_geom_stiffness, first_load_increment=first_load_increment,
                   min_load_increment=min_load_increment, max_load_increment=max_load_increment,
                   termination_control=termination_control, termination_value=termination_value,
                   residual_control=residual_control, force_residual=force_residual,
                   moment_residual=moment_residual, disp_control=disp_control,
                   disp_control_node=disp_control_node, disp_control_dir=disp_control_dir,
                   disp_control_limit=disp_control_limit, load_control=load_control,
                   load_control_factor=load_control_factor, element_list=element_list,
                   report_cycle=report_cycle, graphic_cycle=graphic_cycle,
                   save_residual=save_residual, damping_type=damping_type,
                   percent_damp_disp=percent_damp_disp, percent_damp_rotn=percent_damp_rotn,
                   dummy_mass_factor=dummy_mass_factor, dummy_inertia_factor=dummy_inertia_factor,
                   dummy_mass_power=dummy_mass_power, dummy_inertia_power=dummy_inertia_power,
                   auto_dummy_mass=auto_dummy_mass, auto_damping=auto_damping,
                   save_elem_load=save_elem_load, save_spacer_load=save_spacer_load,
                   show_progress=show_progress, show_graphic=show_graphic, result_output=result_output)

    def to_gwa(self):
        '''
        Compiles TASK gwa record.

        :return: TASK gwa record
        '''
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.stage, "GSRelax",
                 self.solution, self.scheme, '0']
        write += ['BEAM_GEO_YES' if self.beam_geom_stiffness else 'BEAM_GEO_NO']
        write += ['SHELL_GEO_YES' if self.shell_geom_stiffness else 'SHELL_GEO_NO']
        write += [self.first_load_increment, self.min_load_increment, self.max_load_increment,
                  self.termination_control, self.termination_value, self.residual_control,
                  self.force_residual, self.moment_residual]
        write += ['DISP_CTRL_YES' if self.disp_control else 'DISP_CTRL_NO']
        write += [self.disp_control_node, self.disp_control_dir, self.disp_control_limit]
        write += ['LOAD_CTRL_YES' if self.load_control else 'LOAD_CTRL_NO']
        write += [self.load_control_factor]
        if self.element_list:
            write += [' '.join([str(x) for x in self.element_list])]
        else:
            write += [""]
        write += [self.report_cycle, self.graphic_cycle, self.save_residual,
                  self.damping_type, self.percent_damp_disp, self.percent_damp_rotn,
                  self.dummy_mass_factor, self.dummy_inertia_factor, self.dummy_mass_power,
                  self.dummy_inertia_power]
        write += ['AUTO_MASS_YES' if self.auto_dummy_mass else 'AUTO_MASS_NO']
        write += ['AUTO_DAMP_YES' if self.auto_damping else 'AUTO_DAMP_NO']
        write += ['FF_SAVE_ELEM_FORCE_YES' if self.save_elem_load else 'FF_SAVE_ELEM_FORCE_NO']
        write += [self.save_spacer_load, self.show_progress, self.show_graphic]
        write += [''.join(self.result_output)]

        return '\t'.join([str(x) for x in write])

    @staticmethod
    def list_from_gwa(desc):
        """
        Unrolls list description. Inserts named lists as is.

        :param desc: GWA list description
        :return: List of entities in GWA list description
        """
        if desc:
            if str.lower(desc).strip() == "none":
                return None
            split = list(filter(None, re.split(" (?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", desc)))
            entities = []
            list_names = []
            while (split):
                x = split.pop(0)
                if x == "to":
                    entities += [x for x in range(entities[len(entities) - 1] + 1, int(split.pop(0)) + 1)]
                elif '"' in x:
                    list_names.append(x)
                else:
                    entities.append(int(x))
            entities.sort()
            entities += list_names
            return entities
        else:
            return None


class AnalysisTaskGSSpecDynamicResp(AnalysisTask):
    '''
    Analysis task module using GSRelax solver for response spectrum analysis.

    :param index: index
    :param name: task name
    :param stage: analysis stage, set to 0 to analyse whole model
    :param mode_task: task containing modal results
    :param basic_combo_method: basic combination method
    :param axis: axis
    :param include_x: include response in x direction
    :param spectrum_x: spectrum in x direction
    :param modes_x: modes in x direction
    :param include_y: include response in y direction
    :param spectrum_y: spectrum in y direction
    :param modes_y: modes in y direction
    :param include_z: include response in z direction
    :param spectrum_z: spectrum in z direction
    :param modes_z: modes in z direction
    :param rigorous_analysis: rigorous or fast analysis
    :param rigid_method: rigid response method
    :param rigid_freq: rigid frequency
    :param low_trans_freq: lower transition frequency
    :param upper_trans_freq: upper transition frequency
    :param damp_calc: damping calculation method
    :param damp_scale: scaling of response spectrum for damping
    :param damp_ratio: damping ratio for constant damping calculation
    :param result_output: a list of AnalysisResultOutputEnum indicating results to be stored
    :param source: source associated with task
    :param drift: a list of named tuples ['name','x','y','storey_list'] indicating storey drifts and forces
    :param disp: a list of named tuples ['name','node_1','node_2','axis'] indicating relative nodal displacements
    :param sID: sID
    '''

    _solver = AnalysisSolverEnum.DYNAMIC_RESP
    _module_name = 'TASK.1'
    stage_default = 0
    mode_task_default = 0
    basic_combo_method_default = GSSpecEnum.COMBO_CQC
    axis_default = 0
    include_x_default = True
    spectrum_x_default = 1
    modes_x_default = 'all'
    include_y_default = True
    spectrum_y_default = 1
    modes_y_default = 'all'
    include_z_default = True
    spectrum_z_default = 1
    modes_z_default = 'all'
    rigorous_analysis_default = True
    rigid_method_default = GSSpecEnum.RIGID_RESP_NO_RIGID
    rigid_freq_default = 33
    low_trans_freq_default = 0
    upper_trans_freq_default = 0
    damp_calc_default = GSSpecEnum.DAMP_CALC_CODE
    damp_scale_default = GSSpecEnum.DAMP_SCALE_CODE
    damp_ratio_default = 0.02
    result_output_default = [
        AnalysisResultOutputEnum.NODE_DISPLACEMENTS,
        AnalysisResultOutputEnum.VELOCITY,
        AnalysisResultOutputEnum.ACCELERATION,
        AnalysisResultOutputEnum.REACTIONS,
        AnalysisResultOutputEnum.CONSTRAINT_FORCES,
        AnalysisResultOutputEnum.MASS,
        AnalysisResultOutputEnum.ELEMENT_DISPLACEMENTS,
        AnalysisResultOutputEnum.FORCES_AND_MOMENTS,
        AnalysisResultOutputEnum.ELEMENT_FORCES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_3D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_3D,
        AnalysisResultOutputEnum.STRAIN_ENERGY_DENSITY,
        AnalysisResultOutputEnum.VALUE_AT_2D_CENTRE_ONLY
    ]
    source_default = 1
    drift_default = []
    disp_default = []

    def __init__(self, index, name, stage=stage_default, mode_task=mode_task_default,
                 basic_combo_method=basic_combo_method_default, axis=axis_default, include_x=include_x_default,
                 spectrum_x=spectrum_x_default, modes_x=modes_x_default, include_y=include_y_default,
                 spectrum_y=spectrum_y_default, modes_y=modes_y_default, include_z=include_z_default,
                 spectrum_z=spectrum_z_default, modes_z=modes_z_default, rigorous_analysis=rigorous_analysis_default,
                 rigid_method=rigid_method_default, rigid_freq=rigid_freq_default,
                 low_trans_freq=low_trans_freq_default,
                 upper_trans_freq=upper_trans_freq_default, damp_calc=damp_calc_default, damp_scale=damp_scale_default,
                 damp_ratio=damp_ratio_default, result_output=result_output_default, source=source_default,
                 drift=drift_default, disp=disp_default, sID=None):
        self.index = index
        self.sID = sID
        self.name = name
        self.stage = stage
        self.mode_task = mode_task
        self.basic_combo_method = basic_combo_method
        self.axis = axis
        self.include_x = include_x
        self.spectrum_x = spectrum_x
        self.modes_x = modes_x
        self.include_y = include_y
        self.spectrum_y = spectrum_y
        self.modes_y = modes_y
        self.include_z = include_z
        self.spectrum_z = spectrum_z
        self.modes_z = modes_z
        self.rigorous_analysis = rigorous_analysis
        self.rigid_method = rigid_method
        self.rigid_freq = rigid_freq
        self.low_trans_freq = low_trans_freq
        self.upper_trans_freq = upper_trans_freq
        self.damp_calc = damp_calc
        self.damp_scale = damp_scale
        self.damp_ratio = damp_ratio
        self.result_output = result_output
        self.source = source
        self.drift = drift
        self.disp = disp

    @classmethod
    def from_gwa(cls, gwa):
        '''
        Interprets TASK gwa record and returns an AnalysisTaskGSSpecDynamicResp object.

        :param gwa: GWA record seperated into a list
        :return: AnalysisTaskGSSpecDynamicResp object
        '''

        # TASK | task | name | stage | GSSPEC | DYNAMIC_RESP | mode_task | modes |
        # responses | damp_calc | damp_scale | damping | result | rigorous |
        # drift < | name | x | y > | storey >|
        # disp < | name | node1 | node2 | axis >

        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = tokens.popleft()
        stage = int(tokens.popleft())
        tokens.popleft()  # GSSPEC
        tokens.popleft()  # DYNAMIC_RESP
        mode_task = int(tokens.popleft())
        basic_combo_method = tokens.popleft()
        axis = int(tokens.popleft())
        include_x = tokens.popleft() == "INCLUDE"
        spectrum_x = int(tokens.popleft())
        modes_x = tokens.popleft()
        include_y = tokens.popleft() == "INCLUDE"
        spectrum_y = int(tokens.popleft())
        modes_y = tokens.popleft()
        include_z = tokens.popleft() == "INCLUDE"
        spectrum_z = int(tokens.popleft())
        modes_z = tokens.popleft()
        rigorous_analysis = tokens.popleft() == "RIGOROUS"
        rigid_method = tokens.popleft()
        rigid_freq = float(tokens.popleft())
        low_trans_freq = float(tokens.popleft())
        upper_trans_freq = float(tokens.popleft())
        damp_calc = tokens.popleft()
        damp_scale = tokens.popleft()
        damp_ratio = float(tokens.popleft())
        result_output = list(tokens.popleft())
        source = int(tokens.popleft())

        num_drift = int(tokens.popleft())
        drift = []
        for x in range(num_drift):
            y = namedtuple('drift', ['name', 'x', 'y', 'storey_list'])
            y.name = tokens.popleft()
            y.x = float(tokens.popleft())
            y.y = float(tokens.popleft())
            y.storey_list = tokens.popleft()
            drift.append(y)

        num_disp = int(tokens.popleft())
        disp = []
        for x in range(num_disp):
            y = namedtuple('disp', ['name', 'node_1', 'node_2', 'axis'])
            y.name = tokens.popleft()
            y.node_1 = int(tokens.popleft())
            y.node_2 = int(tokens.popleft())
            y.axis = int(tokens.popleft())
            disp.append(y)

        return cls(index, sID=sID, name=name, stage=stage, mode_task=mode_task,
                   basic_combo_method=basic_combo_method, axis=axis, include_x=include_x,
                   spectrum_x=spectrum_x, modes_x=modes_x, include_y=include_y,
                   spectrum_y=spectrum_y, modes_y=modes_y, include_z=include_z,
                   spectrum_z=spectrum_z, modes_z=modes_z, rigorous_analysis=rigorous_analysis,
                   rigid_method=rigid_method, rigid_freq=rigid_freq, low_trans_freq=low_trans_freq,
                   upper_trans_freq=upper_trans_freq, damp_calc=damp_calc, damp_scale=damp_scale,
                   damp_ratio=damp_ratio, result_output=result_output, source=source,
                   drift=drift, disp=disp)

    def to_gwa(self):
        '''
        Compiles TASK gwa record.

        :return: TASK gwa record
        '''
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.stage, "GSSPEC",
                 "DYNAMIC_RESP", self.mode_task, self.basic_combo_method, self.axis]
        write += ["INCLUDE" if self.include_x else "EXCLUDE"]
        write += [self.spectrum_x, self.modes_x]
        write += ["INCLUDE" if self.include_y else "EXCLUDE"]
        write += [self.spectrum_y, self.modes_y]
        write += ["INCLUDE" if self.include_y else "EXCLUDE"]
        write += [self.spectrum_y, self.modes_y]
        write += ["RIGOROUS" if self.rigorous_analysis else "FAST"]
        write += [self.rigid_method, self.rigid_freq, self.low_trans_freq, self.upper_trans_freq,
                  self.damp_calc, self.damp_scale, self.damp_ratio]
        write += [''.join(self.result_output)]
        write += [self.source, len(self.drift)]
        for d in self.drift:
            write += [d.name, d.x, d.y, d.storey_list]
        write += [len(self.disp)]
        for d in self.disp:
            write += [d.name, d.node_1, d.node_2, d.axis]

        return '\t'.join([str(x) for x in write])


class AnalysisTaskGSSpecPseudoRSA(AnalysisTask):
    '''
    Analysis task module using GSRelax solver for response spectrum analysis.
    Does not support CQC3 combination.

    :param index: index
    :param name: task name
    :param stage: analysis stage, set to 0 to analyse whole model
    :param mode_task: task containing modal results
    :param basic_combo_method: basic combination method
    :param axis: axis
    :param include_x: include response in x direction
    :param spectrum_x: spectrum in x direction
    :param modes_x: modes in x direction
    :param include_y: include response in y direction
    :param spectrum_y: spectrum in y direction
    :param modes_y: modes in y direction
    :param include_z: include response in z direction
    :param spectrum_z: spectrum in z direction
    :param modes_z: modes in z direction
    :param rigorous_analysis: rigorous or fast analysis
    :param rigid_method: rigid response method
    :param rigid_freq: rigid frequency
    :param low_trans_freq: lower transition frequency
    :param upper_trans_freq: upper transition frequency
    :param damp_calc: damping calculation method
    :param damp_scale: scaling of response spectrum for damping
    :param damp_ratio: damping ratio for constant damping calculation
    :param result_output: a list of AnalysisResultOutputEnum indicating results to be stored
    :param source: source associated with task
    :param drift: a list of named tuples ['name','x','y','storey_list'] indicating storey drifts and forces
    :param disp: a list of named tuples ['name','node_1','node_2','axis'] indicating relative nodal displacements
    :param mode: a list of named tuples ['freq','m','u_x','u_y','u_z'] indicating modal sets
    :param sID: sID
    '''

    _solver = AnalysisSolverEnum.PSEUDO_RSA
    _module_name = 'TASK.1'
    stage_default = 0
    mode_task_default = 0
    basic_combo_method_default = GSSpecEnum.COMBO_CQC
    axis_default = 0
    include_x_default = True
    spectrum_x_default = 1
    modes_x_default = 'all'
    include_y_default = True
    spectrum_y_default = 1
    modes_y_default = 'all'
    include_z_default = True
    spectrum_z_default = 1
    modes_z_default = 'all'
    rigorous_analysis_default = True
    rigid_method_default = GSSpecEnum.RIGID_RESP_NO_RIGID
    rigid_freq_default = 33
    low_trans_freq_default = 0
    upper_trans_freq_default = 0
    damp_calc_default = GSSpecEnum.DAMP_CALC_CODE
    damp_scale_default = GSSpecEnum.DAMP_SCALE_CODE
    damp_ratio_default = 0.02
    result_output_default = [
        AnalysisResultOutputEnum.NODE_DISPLACEMENTS,
        AnalysisResultOutputEnum.VELOCITY,
        AnalysisResultOutputEnum.ACCELERATION,
        AnalysisResultOutputEnum.REACTIONS,
        AnalysisResultOutputEnum.CONSTRAINT_FORCES,
        AnalysisResultOutputEnum.MASS,
        AnalysisResultOutputEnum.ELEMENT_DISPLACEMENTS,
        AnalysisResultOutputEnum.FORCES_AND_MOMENTS,
        AnalysisResultOutputEnum.ELEMENT_FORCES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_3D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_3D,
        AnalysisResultOutputEnum.STRAIN_ENERGY_DENSITY,
        AnalysisResultOutputEnum.VALUE_AT_2D_CENTRE_ONLY
    ]
    source_default = 1
    drift_default = []
    disp_default = []
    mode_default = []

    # TODO - fix these defaults: they are mutable

    def __init__(self, index, name, stage=stage_default, mode_task=mode_task_default,
                 basic_combo_method=basic_combo_method_default, axis=axis_default, include_x=include_x_default,
                 spectrum_x=spectrum_x_default, modes_x=modes_x_default, include_y=include_y_default,
                 spectrum_y=spectrum_y_default, modes_y=modes_y_default, include_z=include_z_default,
                 spectrum_z=spectrum_z_default, modes_z=modes_z_default, rigorous_analysis=rigorous_analysis_default,
                 rigid_method=rigid_method_default, rigid_freq=rigid_freq_default,
                 low_trans_freq=low_trans_freq_default,
                 upper_trans_freq=upper_trans_freq_default, damp_calc=damp_calc_default, damp_scale=damp_scale_default,
                 damp_ratio=damp_ratio_default, result_output=result_output_default, source=source_default,
                 drift=drift_default, disp=disp_default, mode=mode_default, sID=None):
        self.index = index
        self.sID = sID
        self.name = name
        self.stage = stage
        self.mode_task = mode_task
        self.basic_combo_method = basic_combo_method
        self.axis = axis
        self.include_x = include_x
        self.spectrum_x = spectrum_x
        self.modes_x = modes_x
        self.include_y = include_y
        self.spectrum_y = spectrum_y
        self.modes_y = modes_y
        self.include_z = include_z
        self.spectrum_z = spectrum_z
        self.modes_z = modes_z
        self.rigorous_analysis = rigorous_analysis
        self.rigid_method = rigid_method
        self.rigid_freq = rigid_freq
        self.low_trans_freq = low_trans_freq
        self.upper_trans_freq = upper_trans_freq
        self.damp_calc = damp_calc
        self.damp_scale = damp_scale
        self.damp_ratio = damp_ratio
        self.result_output = result_output
        self.source = source
        self.drift = drift
        self.disp = disp
        self.mode = mode

    @classmethod
    def from_gwa(cls, gwa):
        '''
        Interprets TASK gwa record and returns an AnalysisTaskGSSpecPseudoRSA object.

        :param gwa: GWA record seperated into a list
        :return: AnalysisTaskGSSpecPseudoRSA object
        '''

        # TASK | task | name | stage | GSSPEC | PSEUDO_RSA | mode_task | modes |
        # responses | damp_calc | damp_scale | damping | result | rigorous |
        # drift < | name | x | y > | storey > |
        # disp < | name | node1 | node2 | axis >|
        # mode < | freq | mass | mx | my | mz >

        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = tokens.popleft()
        stage = int(tokens.popleft())
        tokens.popleft()  # GSSPEC
        tokens.popleft()  # PSEUDO_RSA
        mode_task = int(tokens.popleft())
        basic_combo_method = tokens.popleft()
        axis = int(tokens.popleft())
        include_x = tokens.popleft() == "INCLUDE"
        spectrum_x = int(tokens.popleft())
        modes_x = tokens.popleft()
        include_y = tokens.popleft() == "INCLUDE"
        spectrum_y = int(tokens.popleft())
        modes_y = tokens.popleft()
        include_z = tokens.popleft() == "INCLUDE"
        spectrum_z = int(tokens.popleft())
        modes_z = tokens.popleft()
        rigorous_analysis = tokens.popleft() == "RIGOROUS"
        rigid_method = tokens.popleft()
        rigid_freq = float(tokens.popleft())
        low_trans_freq = float(tokens.popleft())
        upper_trans_freq = float(tokens.popleft())
        damp_calc = tokens.popleft()
        damp_scale = tokens.popleft()
        damp_ratio = float(tokens.popleft())
        result_output = list(tokens.popleft())
        source = int(tokens.popleft())

        num_drift = int(tokens.popleft())
        drift = []
        for x in range(num_drift):
            y = namedtuple('drift', ['name', 'x', 'y', 'storey_list'])
            y.name = tokens.popleft()
            y.x = float(tokens.popleft())
            y.y = float(tokens.popleft())
            y.storey_list = tokens.popleft()
            drift.append(y)

        num_disp = int(tokens.popleft())
        disp = []
        for x in range(num_disp):
            y = namedtuple('disp', ['name', 'node_1', 'node_2', 'axis'])
            y.name = tokens.popleft()
            y.node_1 = int(tokens.popleft())
            y.node_2 = int(tokens.popleft())
            y.axis = int(tokens.popleft())
            disp.append(y)

        num_mode = int(tokens.popleft())
        mode = []
        for x in range(num_mode):
            y = namedtuple('mode', ['freq', 'm', 'u_x', 'u_y', 'u_z'])
            y.freq = float(tokens.popleft())
            y.m = float(tokens.popleft())
            y.u_x = float(tokens.popleft())
            y.u_y = float(tokens.popleft())
            y.u_z = float(tokens.popleft())
            mode.append(y)

        return cls(index, sID=sID, name=name, stage=stage, mode_task=mode_task,
                   basic_combo_method=basic_combo_method, axis=axis, include_x=include_x,
                   spectrum_x=spectrum_x, modes_x=modes_x, include_y=include_y,
                   spectrum_y=spectrum_y, modes_y=modes_y, include_z=include_z,
                   spectrum_z=spectrum_z, modes_z=modes_z, rigorous_analysis=rigorous_analysis,
                   rigid_method=rigid_method, rigid_freq=rigid_freq, low_trans_freq=low_trans_freq,
                   upper_trans_freq=upper_trans_freq, damp_calc=damp_calc, damp_scale=damp_scale,
                   damp_ratio=damp_ratio, result_output=result_output, source=source,
                   drift=drift, disp=disp, mode=mode)

    def to_gwa(self):
        '''
        Compiles TASK gwa record.

        :return: TASK gwa record
        '''
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.stage, "GSSPEC",
                 "PSEUDO_RSA", self.mode_task, self.basic_combo_method, self.axis]
        write += ["INCLUDE" if self.include_x else "EXCLUDE"]
        write += [self.spectrum_x, self.modes_x]
        write += ["INCLUDE" if self.include_y else "EXCLUDE"]
        write += [self.spectrum_y, self.modes_y]
        write += ["INCLUDE" if self.include_y else "EXCLUDE"]
        write += [self.spectrum_y, self.modes_y]
        write += ["RIGOROUS" if self.rigorous_analysis else "FAST"]
        write += [self.rigid_method, self.rigid_freq, self.low_trans_freq, self.upper_trans_freq,
                  self.damp_calc, self.damp_scale, self.damp_ratio]
        write += [''.join(self.result_output)]
        write += [self.source, len(self.drift)]
        for d in self.drift:
            write += [d.name, d.x, d.y, d.storey_list]
        write += [len(self.disp)]
        for d in self.disp:
            write += [d.name, d.node_1, d.node_2, d.axis]
        write += [len(self.mode)]
        for m in self.mode:
            write += [m.freq, m.m, m.u_x, m.u_y, m.u_z]

        return '\t'.join([str(x) for x in write])

    def __repr__(self):
        return self.to_gwa()

    def __str__(self):
        return self.to_gwa()


class AnalysisTaskGSSpecHarmonic(AnalysisTask):
    '''
    Analysis task module using GSRelax solver for harmonic analysis.

    :param index: index
    :param name: task name
    :param stage: analysis stage, set to 0 to analyse whole model
    :param mode_task: task containing modal results
    :param load_description: load description
    :param freq_start: start load frequency
    :param freq_end: end load frequency
    :param freq_inc: load frequency increment
    :param damp_calc: damping calculation method
    :param damp_table_ref: damping table reference
    :param damp_ratio: percentage of critical damping ratio
    :param result_output: a list of AnalysisResultOutputEnum indicating results to be stored
    :param sID: sID
    '''
    _solver = AnalysisSolverEnum.HARMONIC
    _module_name = 'TASK.1'
    stage_default = 0
    mode_task_default = 0
    load_description_default = ""
    freq_start_default = 1
    freq_end_default = 2.5
    freq_inc_default = 0.2
    damp_calc_default = GSSpecEnum.DAMP_CALC_CONST
    damp_table_ref_default = 0
    damp_ratio_default = 0.02
    result_output_default = [  # TODO - this is mutable!
        AnalysisResultOutputEnum.NODE_DISPLACEMENTS,
        AnalysisResultOutputEnum.VELOCITY,
        AnalysisResultOutputEnum.ACCELERATION,
        AnalysisResultOutputEnum.REACTIONS,
        AnalysisResultOutputEnum.CONSTRAINT_FORCES,
        AnalysisResultOutputEnum.MASS,
        AnalysisResultOutputEnum.ELEMENT_DISPLACEMENTS,
        AnalysisResultOutputEnum.FORCES_AND_MOMENTS,
        AnalysisResultOutputEnum.ELEMENT_FORCES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_3D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_3D,
        AnalysisResultOutputEnum.STRAIN_ENERGY_DENSITY,
        AnalysisResultOutputEnum.VALUE_AT_2D_CENTRE_ONLY
    ]

    def __init__(self, index, name, stage=stage_default,
                 mode_task=mode_task_default, load_description=load_description_default,
                 freq_start=freq_start_default, freq_end=freq_end_default,
                 freq_inc=freq_inc_default, damp_calc=damp_calc_default,
                 damp_table_ref=damp_table_ref_default, damp_ratio=damp_ratio_default,
                 result_output=result_output_default, sID=None):
        self.index = index
        self.sID = sID
        self.name = name
        self.stage = stage
        self.mode_task = mode_task
        self.load_description = load_description
        self.freq_start = freq_start
        self.freq_end = freq_end
        self.freq_inc = freq_inc
        self.damp_calc = damp_calc
        self.damp_table_ref = damp_table_ref
        self.damp_ratio = damp_ratio
        self.result_output = result_output

    @classmethod
    def from_gwa(cls, gwa):
        '''
        Interprets TASK gwa record and returns an AnalysisTaskGSSpecHarmonic object.

        :param gwa: GWA record seperated into a list
        :return: AnalysisTaskGSSpecHarmonic object
        '''

        # TASK | task | name | stage | GSSPEC | HARMONIC | mode_task |load |
        # low_freq | high_freq | freq_inc | damp_op | damp_table | damping | result

        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = tokens.popleft()
        stage = int(tokens.popleft())
        tokens.popleft()  # GSSPEC
        tokens.popleft()  # HARMONIC
        mode_task = int(tokens.popleft())
        load_description = tokens.popleft()
        freq_start = float(tokens.popleft())
        freq_end = float(tokens.popleft())
        freq_inc = float(tokens.popleft())
        damp_calc = tokens.popleft()
        damp_table_ref = int(tokens.popleft())
        damp_ratio = float(tokens.popleft())
        result_output = list(tokens.popleft())

        return cls(index, sID=sID, name=name, stage=stage, mode_task=mode_task,
                   load_description=load_description, freq_start=freq_start, freq_end=freq_end,
                   freq_inc=freq_inc, damp_calc=damp_calc, damp_table_ref=damp_table_ref,
                   damp_ratio=damp_ratio, result_output=result_output)

    def to_gwa(self):
        '''
        Compiles TASK gwa record.

        :return: TASK gwa record
        '''
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.stage, "GSSPEC",
                 "HARMONIC", self.mode_task, self.load_description, self.freq_start,
                 self.freq_end, self.freq_inc, self.damp_calc, self.damp_table_ref,
                 self.damp_ratio]
        write += [''.join(self.result_output)]

        return '\t'.join([str(x) for x in write])


class AnalysisTaskGSSpecTimeHistory(AnalysisTask):
    '''
    Analysis task module using GSRelax solver for time history analysis.

    :param index: index
    :param name: task name
    :param stage: analysis stage, set to 0 to analyse whole model
    :param mode_task: task containing modal results
    :param excite_type: type of excitation
    :param load_description: load description
    :param history_ref: load curve reference for time history
    :param time_int_out: time interval for output
    :param time_int_hist_out: time interval for time-history output
    :param time_stop: stop time
    :param time_step: time step, set to 0 for auto
    :param damp_calc: damping calculation method
    :param damp_table_ref: damping table reference
    :param damp_ratio: percentage of critical damping ratio
    :param result_output: a list of AnalysisResultOutputEnum indicating results to be stored
    :param sID: sID
    '''
    _solver = AnalysisSolverEnum.TIME_HISTORY
    _module_name = 'TASK.1'
    stage_default = 0
    mode_task_default = 0
    excite_type_default = GSSpecEnum.EXCITE_TYPE_LOAD
    load_description_default = ""
    history_ref_default = 1
    time_int_out_default = 0.1
    time_int_hist_out_default = 0.001
    time_stop_default = 1
    time_step_default = 0
    damp_calc_default = GSSpecEnum.DAMP_CALC_CONST
    damp_table_ref_default = 0
    damp_ratio_default = 0.02
    result_output_default = [
        AnalysisResultOutputEnum.NODE_DISPLACEMENTS,
        AnalysisResultOutputEnum.VELOCITY,
        AnalysisResultOutputEnum.ACCELERATION,
        AnalysisResultOutputEnum.REACTIONS,
        AnalysisResultOutputEnum.CONSTRAINT_FORCES,
        AnalysisResultOutputEnum.MASS,
        AnalysisResultOutputEnum.ELEMENT_DISPLACEMENTS,
        AnalysisResultOutputEnum.FORCES_AND_MOMENTS,
        AnalysisResultOutputEnum.ELEMENT_FORCES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_2D,
        AnalysisResultOutputEnum.ELEMENT_LOCAL_STRESSES_3D,
        AnalysisResultOutputEnum.ELEMENT_GLOBAL_STRESSES_3D,
        AnalysisResultOutputEnum.STRAIN_ENERGY_DENSITY,
        AnalysisResultOutputEnum.VALUE_AT_2D_CENTRE_ONLY
    ]

    def __init__(self, index, name, stage=stage_default,
                 mode_task=mode_task_default, excite_type=excite_type_default,
                 load_description=load_description_default, history_ref=history_ref_default,
                 time_int_out=time_int_out_default, time_int_hist_out=time_int_hist_out_default,
                 time_stop=time_stop_default, time_step=time_step_default,
                 damp_calc=damp_calc_default, damp_table_ref=damp_table_ref_default,
                 damp_ratio=damp_ratio_default, result_output=result_output_default, sID=None):
        self.index = index
        self.sID = sID
        self.name = name
        self.stage = stage
        self.mode_task = mode_task
        self.excite_type = excite_type
        self.load_description = load_description
        self.history_ref = history_ref
        self.time_int_out = time_int_out
        self.time_int_hist_out = time_int_hist_out
        self.time_stop = time_stop
        self.time_step = time_step
        self.damp_calc = damp_calc
        self.damp_table_ref = damp_table_ref
        self.damp_ratio = damp_ratio
        self.result_output = result_output

    @classmethod
    def from_gwa(cls, gwa):
        '''
        Interprets TASK gwa record and returns an AnalysisTaskGSSpecTimeHistory object.

        :param gwa: GWA record seperated into a list
        :return: AnalysisTaskGSSpecTimeHistory object
        '''

        # TASK | task | name | stage | GSSPEC | TIME_HISTORY | mode_task | LOAD_EXCITE |
        # load | history | time_out | time_hist | stop | step | damp_op | damp_table | damping | results

        gwa_error = gwa
        tokens = deque(gwa)
        record_sID = tokens.popleft()
        _, sID = _parse_record_sID(record_sID)
        index = int(tokens.popleft())
        name = tokens.popleft()
        stage = int(tokens.popleft())
        tokens.popleft()  # GSSPEC
        tokens.popleft()  # TIME_HISTORY
        mode_task = int(tokens.popleft())
        excite_type = tokens.popleft()
        load_description = tokens.popleft()
        history_ref = int(tokens.popleft())
        time_int_out = float(tokens.popleft())
        time_int_hist_out = float(tokens.popleft())
        time_stop = float(tokens.popleft())
        time_step = float(tokens.popleft())
        damp_calc = tokens.popleft()
        damp_table_ref = int(tokens.popleft())
        damp_ratio = float(tokens.popleft())
        result_output = list(tokens.popleft())

        return cls(index, sID=sID, name=name, stage=stage, mode_task=mode_task,
                   excite_type=excite_type, load_description=load_description, history_ref=history_ref,
                   time_int_out=time_int_out, time_int_hist_out=time_int_hist_out, time_stop=time_stop,
                   time_step=time_step, damp_calc=damp_calc, damp_table_ref=damp_table_ref, damp_ratio=damp_ratio,
                   result_output=result_output)

    def to_gwa(self):
        '''
        Compiles TASK gwa record.

        :return: TASK gwa record
        '''
        write = [self._module_name + _write_sID(self.sID), self.index, self.name, self.stage, "GSSPEC",
                 "TIME_HISTORY", self.mode_task, self.excite_type, self.load_description, self.history_ref,
                 self.time_int_out, self.time_int_hist_out, self.time_stop, self.time_step, self.damp_calc,
                 self.damp_table_ref, self.damp_ratio]
        write += [''.join(self.result_output)]

        return '\t'.join([str(x) for x in write])


class GSAList(_ModuleOrdered):
    """ Uses LIST syntax: LIST | num | name | type | list
    """
    _module_name = "LIST"
    _syntax = "LIST | num | name | type | list"
    _attr = ['index', 'name', 'type', 'description']
    _syntax_attr_rename = {
        'description': 'list',
        'index': 'num',
    }

    name_default = 'list'
    type_default = "NODE"
    description_default = ""

    def __init__(self, index, sID='', name=name_default, type=type_default, description=description_default):
        self.index = index
        self.sID = sID
        self.name = name
        self.type = type
        self.description = description
