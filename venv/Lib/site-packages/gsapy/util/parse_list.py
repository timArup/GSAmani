from re import findall, compile, IGNORECASE

__all__ = ['parse_list', 'expand_tree', 'expand_list']

number = compile('\d+', IGNORECASE)
case = compile('([AC])(\d+)(?:p(\d+)|(max|min|abs|signabs))?', IGNORECASE)
conjunction = compile('to|not|step', IGNORECASE)
bracket = compile('[\(\)]')
all_items = compile('all', IGNORECASE)

tokenize_re = compile("[\w\d]+|\(|\)", IGNORECASE)


def parse_list(list):
    """
    This function takes a GSA-style list description and parses it into an Abstract Syntax Tree (AST).
    The nodes of the AST are python dicts, which is only guaranteed to have a 'type' key. Each type of
    node has different properties.

    NUMBER: 'index' - the number

    CASE: 'case_type' - A or C, 'index' - the case number, 'perm' - the permutation or None,
    'modifier' - the case modifier (MIN, MAX, ABS, SIGNABS) or None

    NOT: 'value' - a node or list of nodes

    'all' - no other keys

    :param list: a GSA-style list description string
    :return: a list of parsed list nodes (NUMBER, CASE, NOT, ALL, sub-lists)
    """
    tokens = tokenize(list)

    index = 0
    statements = []
    while index < len(tokens):
        (index, m) = parse_statement(tokens, index)
        if not m:
            raise SyntaxError(f"Parsing failed at {tokens[index]}")
        statements.append(m)
    return statements


def tokenize(list):
    """
    Breaks a GSA-style list into individual tokens and parses each token into dicts

    :param list: a GSA-style list description string
    :return: a python list of dicts, each representing a token
    """
    return [parse_token(t) for t in tokenize_re.findall(list)]


def parse_token(token):
    """
    Parses a single token, returning a dict with the token information.

    :param token: a string representing a single GSA-style list token E.G. 'C1p10', '55', 'A1', 'not' or 'step'
    :return: a dict that stores information about the token
    """
    if number.fullmatch(token):
        m = number.fullmatch(token)
        return {'type': 'NUMBER', 'index': int(m.group(0))}
    if case.fullmatch(token):
        m = case.fullmatch(token)
        if m.group(1) == 'A' and (m.group(3) is not None or m.group(4) is not None):
            return {'type': 'INVALID', 'raw': token}  # Analysis cases cannot have permutations or modifiers
        return {'type': 'CASE',
                'case_type': m.group(1).upper(),
                'index': int(m.group(2)),
                'perm': None if m.group(3) is None else int(m.group(3)),
                'modifier': None if m.group(4) is None else m.group(4).upper()}
    if conjunction.match(token):
        return {'type': 'CONJUNCTION', 'value': token.upper()}
    if bracket.match(token):
        return {'type': 'BRACKET', 'value': token}
    if all_items.fullmatch(token):
        return {'type': 'ALL'}

    return {'type': 'INVALID', 'raw': token}


# The parse_* functions all take a list of tokens and an index as input, and return a tuple of an index and a match.
# If the function matches the tokens starting from the current index, it returns a new index and the parsed data to
# add to the output. If the function does not match, it return the original index and False.


def parse_single(tokens, index):
    """
    Attempts to parse a single token, either a case or a number.
    """
    if tokens[index]['type'] in ('CASE', 'NUMBER', 'ALL'):
        return (index + 1, tokens[index])
    else:
        return (index, False)


to = compile('to', IGNORECASE)


def parse_range(tokens, index):
    """
    Attempts to parse a range, either a case or a number range. E.G. '1 to 10 step 3' or '1 to 15'
    """
    try:
        try:
            if tokens[index + 1]['value'] != 'TO':
                return (index, False)
        except KeyError:
            return (index, False)
        if tokens[index]['type'] != tokens[index + 2]['type']:
            return (index, False)
        if tokens[index]['type'] != 'CASE' and tokens[index]['type'] != 'NUMBER':
            return (index, False)

        r = {'type': 'RANGE',
             'start': tokens[index],
             'end': tokens[index + 2]}

        try:
            if tokens[index + 3]['type'] == 'CONJUNCTION' and tokens[index + 3]['value'] == 'STEP':
                delta = 5
                if tokens[index + 4]['type'] == 'NUMBER':
                    r['step'] = tokens[index + 4]['index']
                else:
                    raise SyntaxError(f"Expected a number after STEP")
            else:
                r['step'] = 1
                delta = 3
        except IndexError:
            r['step'] = 1
            delta = 3
        return (index + delta, r)
    except IndexError:
        return (index, False)


def parse_bracket_expression(tokens, index):
    """
    Attempts to parse an expression in parentheses. E.G. "(1 5 10)"
    """
    if tokens[index]['type'] != 'BRACKET' or tokens[index]['value'] != '(':
        return (index, False)
    result = []
    index = index + 1
    while index < len(tokens):
        (index, m) = parse_statement(tokens, index)
        if m:
            result.append(m)
            continue
        if tokens[index]['type'] == 'BRACKET' and tokens[index]['value'] == ')':
            return (index + 1, result)
    raise SyntaxError("Unmatched parentheses")


def parse_not(tokens, index):
    """
    Attempts to parse the keyword NOT followed by a single expression. The following expression can be in parentheses to
    negate a compound expression.
    """
    if tokens[index]['type'] != 'CONJUNCTION' or tokens[index]['value'] != 'NOT':
        return (index, False)
    (index, m) = parse_statement(tokens, index + 1)
    if m:
        return (index, {'type': 'NOT', 'value': m})
    raise SyntaxError("Invalid expression following NOT")


# This list defines the precedence of statements in the parser
# New kinds of top level statements must be included in this list
statement_rules = [parse_bracket_expression, parse_not, parse_range, parse_single]


def parse_statement(tokens, index):
    """
    Attempts to parse a single statement from the token stream. The list of attempted statements and their order
    of precedence are defined in the module-level variable `statement_rules`.
    """
    for rule in statement_rules:
        # print(f"{index}: {rule}")
        (index, match) = rule(tokens, index)
        if match:
            return (index, match)
    return (index, False)


def print_case(case):
    """
    Prints a case dict as a GSA-style string.
    :param case: a dict representing a case token
    :return: a GSA-style string representing the case
    """
    if case['type'] != 'CASE':
        raise ValueError(f"Not a case: {case}")
    c = f"{case['case_type']}{case['index']}"
    if case['perm'] is not None:
        c = f"{c}p{case['perm']}"
    else:
        if case['modifier'] is not None:
            c = f"{c}{case['modifier']}"
    return c


def expand_tree(root, items=None):
    """
    Expands a parsed Abstract Syntax Tree into a list of individual items.

    This list contains all the possible items, even those that do not exist in a particular GSA model.

    :param root: a node of a parse AST or a list of such nodes
    :param items: a list to add expanded items to. If none is passed, a new list is created.
    :return: the `items` list with items added or removed (in the case of NOT), or a new list if none was specified
    """
    if items is None:
        items = []
    if type(root) == list:
        for r in root:
            expand_tree(r, items)
        return items
    if root['type'] == 'NUMBER':
        items.append(root['index'])
        return items
    if root['type'] == 'CASE':
        items.append(print_case(root))
        return items
    if root['type'] == 'NOT':
        for item in expand_tree(root['value']):
            try:
                items.remove(item)
            except ValueError:
                pass
        return items
    if root['type'] == 'RANGE':
        r = range(root['start']['index'],
                  root['end']['index'] + 1,
                  root['step'])
        if root['start']['type'] == 'CASE':
            if root['start']['perm'] is None:
                if root['start']['modifier'] is None:
                    # no permutations, no modifiers
                    items.extend({f"{root['start']['case_type']}{i}" for i in r})
                else:
                    # no permutation, but modifier
                    items.extend({f"{root['start']['case_type']}{i}{root['start']['modifier']}" for i in r})
            else:
                # permutation
                if root['start']['index'] == root['end']['index']:
                    # expand the permutations
                    r = range(root['start']['perm'],
                              root['end']['perm'] + 1,
                              root['step'])
                    items.extend({f"{root['start']['case_type']}{root['start']['index']}p{p}" for p in r})
                else:
                    # expand the cases
                    items.extend({f"{root['start']['case_type']}{i}p{root['start']['perm']}" for i in r})
        else:  # this means it is a number range
            items.extend(r)
        return items


def expand_list(gsa_list):
    """
    Expands a GSA-style list into a list of individual items. The list can either be a list of number or a
    list of analysis and combination cases. This list contains all the possible items, even those that do
    not exist in a particular GSA model.


    :param gsa_list: a GSA-style list description string
    :return: a python list of individual items: either integers or GSA-style case strings
    """
    return expand_tree(parse_list(gsa_list))
