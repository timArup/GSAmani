# -*- coding: utf-8 -*-
'''
Copyright (c) 2016 - 2021, Arup

Current & Previous contributors are:

David de Koning, Jenessa Man, Alex De Oliveira, Sébastien Côté, James Angevine

Permission is hereby granted, free of charge, to any person obtaining a copy of
 this software and associated documentation files (the "Software"), to deal in
 the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do
 so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'''

from comtypes.client import CreateObject
from comtypes import CLSCTX_LOCAL_SERVER
from comtypes import COMError
import sys

from os.path import abspath, exists
from re import fullmatch, search
import csv
from typing import List

from collections import defaultdict
import sqlite3

from gsapy.output_dataref import Output_DataRef as dr
from gsapy.util import GSAError
from gsapy.enum import *
from gsapy.modules import *
from gsapy.modules import _parse_record_sID, _ModuleOrdered
from gsapy.structs import structs

import logging

from ._version import get_versions
__version__ = get_versions()['version']
del get_versions

log = logging.getLogger(__name__)

class LocaleEnum(IntEnum):
    LOC_SYSTEM = 1
    LOC_EN_GB = 2


# class GSAError(Exception):
#     def __init__(self, *args, **kwargs):
#         Exception.__init__(self, *args, **kwargs)

# namedtuples for view functions
# TODO: can we delete these? I don't think they add anything -ddk
view_options = namedtuple("view_options", ["PGV", "SGV", "POV", "SOV", "LST"])(
    "PGV", "SGV", "POV", "SOV", "LST")

batch_view_options = namedtuple("batch_view_options",
                                ["ALL_PGV",
                                 "ALL_SGV",
                                 "ALL_POV",
                                 "ALL_SOV",
                                 "ALL_LST",
                                 "TAGGED_PGV",
                                 "TAGGED_SGV",
                                 "TAGGED_POV",
                                 "TAGGED_SOV",
                                 "TAGGED_LST"])("ALL_PGV",
                                                "ALL_SGV",
                                                "ALL_POV",
                                                "ALL_SOV",
                                                "ALL_LST",
                                                "TAGGED_PGV",
                                                "TAGGED_SGV",
                                                "TAGGED_POV",
                                                "TAGGED_SOV",
                                                "TAGGED_LST")
saved_view_options = namedtuple(
    "saved_view_options", ["SGV", "SOV"])("SGV", "SOV")

file_type_options = namedtuple(
    "file_type", [
        "WMF", "PNG", "JPG", "TXT", "CSV", "HTM"])(
    "WMF", "PNG", "JPG", "TXT", "CSV", "HTM")

list_options = namedtuple(
    "list_options", [
        "ITEM", "NODE", "ELEM", "MEMBER", "CASE_ANAL", "CASE_COMB", "GRID_PT"])(
    "ITEM", "NODE", "ELEM", "MEMBER", "CASE_ANAL", "CASE_COMB", "GRID_PT")

case_type_options = namedtuple("case_type_options", ["L", "A", "C"])("L", "A", "C")

case_perm_type_options = namedtuple("case_perm_type_options", ["A", "C"])("A", "C")


# TODO: add class for User Modules and User _Module data points

# TODO: add class for groups

def check_file_version(path):
    """
    Function that checks a GSA file's version without opening GSA.

    :param path: path to the GSA file.
    :return: the GSA major version of the file as a string
    """
    try:
        with open(path, "rb") as file:
            raw_header = file.read(200)

        tokens = raw_header.split(sep=b'\x00')
        simple_version = tokens[13].decode("utf-8") # simple_version is in the format major.minor
        #print(f"Raw simple_version: {simple_version}")

        complete_version = tokens[14].decode("utf-8") # complete_version is in the format major.minor.X.release
        #print(f"complete_version: {complete_version}")
        try:
            v = complete_version.split('.')[0:2]
            #print(f"v: {v}")
            mv = f"{v[0]}.{v[1]}"
            float(mv) # check that we got a reasonable number, we will fall back to the other
            return mv
        except ValueError:
            pass
        except IndexError:
            pass

        return simple_version
    except FileNotFoundError:
        raise
    except (IOError, IndexError) as e:
        raise GSAError("Could not check file version, probably not a GSA file.") from e




class GSA(object):
    """
    This is the main class in the gsapy library. Each instance of GSA represents an GSA file opened in GSA.
    """

    def gsapy_logging(self, func_name):
        """
        :param func_name: Function to be logged
        :return: No variables returned
        """
        # self.gsapy_logging(sys._getframe().f_code.co_name)
        feature_description = f"gsapy::{__version__}::function::{func_name}"
        if self.gsa.LogFeatureUsage(feature_description) != 0:
            self.log.info("Could not log gsapy usage")

    class Output_Init_Flags(IntEnum):
        OP_INIT_2D_BOTTOM = 0x1  # output 2D stresses at bottom layer
        OP_INIT_2D_MIDDLE = 0x2  # output 2D stresses at middle layer
        OP_INIT_2D_TOP = 0x4  # output 2D stresses at top layer
        OP_INIT_2D_BENDING = 0x8  # output 2D stresses at bending layer
        OP_INIT_2D_AVGE = 0x10  # average 2D element stresses at nodes
        OP_INIT_1D_AUTO_PTS = 0x20  # calculate 1D results at interesting points
        OP_INIT_INFINITY = 0x40  # return infinity and NaN values as such, else as zero
        # output secondary stick of wall equivalent beam results, else primary
        OP_INIT_1D_WALL_RES_SECONDARY = 0x80

    class Output_IsDataRef_Flags(IntEnum):
        OP_IS_AND = 0x1  # otherwise OR
        OP_IS_PER_REC = 0x2
        OP_IS_PER_NODE = 0x4
        OP_IS_PER_ELEM = 0x8
        OP_IS_PER_MEMB = 0x10
        OP_IS_PER_1D_DISP = 0x20
        OP_IS_PER_1D_FRC = 0x40
        OP_IS_PER_TOPO = 0x80
        OP_IS_AT_CENTRE = 0x100

    def validate_case(self, case, checkForResults=False):
        """
        This function tests a case description to see if it is valid, and returns as follows:

        * if the case is not a valid case string, it returns false
        * if the case is a valid case string, but it doesn't exist in the model, a GSAError is raised
        * if the case is valid and exists, and checkForResults=True, and no results exist, a GSAError is raised
        * if none of the above happens, it returns a tuple of ('A' or 'C', the number of the case, the permutation number),
          the permutation is set to None if it is not a combination case

        :param case: a string with the case description to be validated
        :param checkForResults: if True, the function with throw a GSAError if no results exist

        :return: a tuple of ('A' or 'C', the number of the case, the permutation number), if the checks are successful
        """

        self.gsapy_logging('GSA.validate_case')
        self.log.info(f"checking case: {case}")
        case_desc = "C(\d+)((?:max)|(?:min)|(?:abs)|(?:signabs)|(?:p\d+))?"
        task_desc = "A(\d+)"

        m = fullmatch(task_desc, case)
        if m:
            t = 'A'
            n = int(m.group(1))
            p = None
        else:
            m = fullmatch(case_desc, case)
            if m:
                t = 'C'
                n = int(m.group(1))
                p = m.group(2)
            else:
                return False

        if self.gsa.CaseExist(t, n) == 0:
            raise GSAError(f"Case {t}{n} does not exist. ({(t,n,p)})")

        if checkForResults and (self.gsa.CaseResultsExist(t, n, 0) == 0):
            raise GSAError(f"Case {t}{n} does not have results. ({(t,n,p)})")

        return (t, n, p)

    def _get_records(self, module_cls, indices):
        '''
        Gets a list of records for the given module class.

        :param module_cls: gsapy type, e.g. gsapy.Node, gsapy.BeamLoad
        :param indices: a single integer index or an iterable of indices. If no indices are provided, all records for
                        module_cls will be returned.

        :return: A single record or list of records as appropriate. These records are delimited strings.
        '''
        if module_cls.__bases__[0]._is_super:  # TODO assuming that has only one base class

            module_name = module_cls._module_name
            super_records = self._get_records(module_cls.__bases__[0], indices)
            records = list(filter(lambda x: _parse_record_sID(x)[0] == module_name, super_records))
            if indices is None:
                return records
            elif isinstance(indices, int):
                try:
                    return records[indices]
                except IndexError:
                    raise GSAError(f'GSA returned nothing for record {module_cls._module_name} index {indices}')
            else:
                try:
                    return [records[x] for x in indices]
                except IndexError:
                    raise GSAError(f'GSA returned nothing for record {module_cls._module_name} index {indices}')

        if indices is None:
            return self._gwa_command(f'GET_ALL\t{module_cls._module_name}\t{indices}')
        elif isinstance(indices, int):
            record = self._gwa_command(f'GET\t{module_cls._module_name}\t{indices}')
            if not record:
                raise GSAError(f'GSA returned nothing for record {module_cls._module_name} index {indices}')
            return record
        else:
            try:
                return [self._get_records(module_cls, index)[0] for index in indices]
            except IndexError:
                raise GSAError(f'GSA returned nothing for record {module_cls._module_name} index {indices}')

    def get(self, module_cls, indices=None):
        """
        Function for getting encapsulated data from a GSA model. This is generally not called directly, use
        the get_nodes, get_element functions.

        :param module_cls: the class of object that you want (eg gsapy.Element or gsapy.Node)
        :param indices: a single integer index or an iterable of indices. If no indices are provided, all records for
                        module_cls will be returned.

        :return: a python object representing a GSA data object, eg. an element, a node, etc...
        """

        # TODO: workaround GET_ALL bug for members and analysis cases
        if module_cls is Member and indices is None:
            return self.get_members()
        if module_cls is AnalysisCase and indices is None:
            return self.get_analysis_case()

        records = self._get_records(module_cls, indices)
        # ADDED TO DELETE...
        if module_cls is Node:
            pass
        # ADDED TO DELETE...
        if isinstance(indices, int):
            return module_cls.from_gwa(records[0])
        elif _ModuleOrdered in module_cls.__bases__:
            return {m.index: m for m in map(module_cls.from_gwa, records) if m is not None}
        else:
            return [module_cls.from_gwa(gwa) for gwa in records]

    def set(self, modules):
        """
        Set a number of module records in the GSA model.

        :param modules: a single module record, dict or iterable of module records, to be set. The modules are set in
                        sequential order

        :return: Nothing
        """
        self.gsapy_logging("GSA.set")
        try:
            if type(modules) == dict:
                for mod in modules.values():
                    self._set_one(mod)
            else:
                for mod in modules:
                    self._set_one(mod)
        except TypeError:
            self._set_one(modules)

    def _set_one(self, module):
        """
        Sets one module - used by the set function.

        :param module: module to set in the GSA model.
        :return: nothing
        """
        gwa = module.to_gwa()
        if type(gwa) is list:
            for record in gwa:
                r = self._gwa_command(record)
                if not r:
                    raise GSAError(f'GSA failed to set record {module}')
        else:
            # self.gwa_command not working for AnalysisTask gwa records
            # AnalysisTask and AnalysisCase classes go through the exact same
            # functions but GwaCommand works for Cases and Tasks...
            r = self._gwa_command(module.to_gwa())
            if not r:
                raise GSAError(f'GSA failed to set record {module}')

    def delete(self, entity_cls, index_low, index_high=None, renumber=False):
        """
        Delete data in a GSA model.

        :param entity_cls: the class of the data you want to delete (eg gsapy.NODE or gsapy.ELEMENT)
        :param index_low: the index of the first item to delete
        :param index_high: the index of the last number to delete. Leave blank to only delete one item.
        :param renumber: set to True to renumber the items.

        :return: no return value
        """
        self.gsapy_logging("GSA.delete")

        mode = 'DELETE' if renumber else 'BLANK'
        self._gwa_command(f'{mode}\t{entity_cls._module_name}\t{index_low}' +
                          (f'\t{index_high}' if index_high else ''))
        # TODO 1 - success? It is unclear how this fails

    def exists(self, entity_cls, index_ref):
        """
        Checks if an item exists.

        :param entity_cls: the class of the data you are checking (eg gsapy.NODE or gsapy.ELEMENT)
        :param index_ref: the index you want to check exists.

        :return: True or value
        """
        self.gsapy_logging("GSA.exists")

        # TODO exists command returns 0 on error?
        try:
            commands = '\n'.join([f'EXIST\t{entity_cls._module_name}\t{index}' for index in index_ref])
        except TypeError:
            commands = f'EXIST\t{entity_cls._module_name}\t{index_ref}'
        return bool(self._gwa_command(commands))

    ##########################################################################
    #   Convenience functions for various modules
    ##########################################################################

    def get_nodes(self, indices=None):
        """
        Get a number of nodes from the GSA model.

        :param indices: either an integer, a GSA list descriptor, or a list of integers and list descriptors.

        :return: a dist of gsapy Node objects whose keys node numbers, and the value are Node objects.
        """
        self.gsapy_logging("GSA.get_nodes")

        if isinstance(indices,str):
            return self.get(Node, self._get_entities_in_list_description(indices, EntityEnum.NODE))
        else:
            return self.get(Node, indices)

    def node_re_map(self, node_list):
        """
        Modifies the restraint string from get_nodes to previous method (10.0 - 6 item boolean list, 10.1 - single string)

        :param node_list: a list of gsapy Node objects whose keys node numbers, andthe value are Node objects

        :return: a modified list changine 10.1 format to 10.0 format
        """
        self.gsapy_logging("GSA.node_re_map")

        temp_list = []
        for n in node_list.values():
            old_string = n.restraint
            new_list = []
            if old_string == "free":
                new_list = None
            elif old_string == "pin":
                new_list = [True, True, True, False, False, False]
            elif old_string == "fix":
                new_list = [True, True, True, True, True, True]
            else:
                new_list = [False, False, False, False, False, False]
                if old_string.find("xx") > -1:
                    new_list[3] = True
                    old_string = old_string.replace("xx", "")
                if old_string.find("yy") > -1:
                    new_list[4] = True
                    old_string = old_string.replace("yy", "")
                if old_string.find("zz") > -1:
                    new_list[5] = True
                    old_string = old_string.replace("zz", "")
                if old_string.find("x") > -1:
                    new_list[0] = True
                if old_string.find("y") > -1:
                    new_list[1] = True
                if old_string.find("z") > -1:
                    new_list[2] = True
            n.restraint = new_list
        return node_list

    def get_elements(self, indices=None):
        """
        Get a number of elements from the GSA model.

        :param indices: either an integer, a GSA list descriptor, or a list of integers and list descriptors.
        :return: a dict of gsapy Element objects whose keys are element numbers and values are Element objects.
        """
        self.gsapy_logging("GSA.get_elements")

        if isinstance(indices, str):
            return self.get(Element, self._get_entities_in_list_description(indices, EntityEnum.EL))
        else:
            return self.get(Element, indices)

    def get_members(self, indices=None):
        """
        Get a number of members from the GSA model.

        :param indices: either an integer, a GSA list descriptor, or a list of integers and list descriptors.
        :return: a dict of gsapy Element objects whose keys are member numbers and values are Member objects.
        """
        self.gsapy_logging("GSA.get_members")

        if indices is None:
            # GWA bug with GETALL, MEMB
            # Workaround: Manually get all indices
            indices = self._get_entities_in_list_description('all', EntityEnum.MEMB)
        
        if isinstance(indices, str):
            return self.get(Member, self._get_entities_in_list_description(indices, EntityEnum.MEMB))
        else:
            return self.get(Member, indices)

    def get_analysis_task(self, indices=None):
        """
        Get analysis tasks from the GSA model.

        :param indices: an integer, or list of integers, of the task ids to get. Leave as None for get all tasks
        :return: a list of AnalysisTask objects
        """
        return self.get(AnalysisTask, indices)

    def get_analysis_case(self, indices=None):
        """
        Get a number of analysis cases from the GSA model.

        :param indices: either an integer or a list of integers.
        :return: a dict of gsapy AnalysisCase objects whose keys are case numbers and values are AnalysisCase objects.
        """

        self.gsapy_logging("GSA.get_analysis_case")
        if indices is None:
            # GWA bug with GETALL, ANAL
            # Workaround: Manually get all indices
            indices = []
            highest_index = self.highest_case(case_type_options.A)
            for x in range(highest_index):
                if self.case_exist(case_type_options.A, x + 1) == 1:
                    indices.append(x + 1)

        return self.get(AnalysisCase, indices)

    def get_section_info(self, section_number, section_info="SECT_NAME"):
        """
        Retrieves section information directly from the GSA section database. This only works for catagloue
        sections, not standard (STD) sections.

        Note: dimensions are not converted to the model units! All dimensions are in metres.

        :param section_number: the gsa reference number of the section in your model
        :param section_info: either a string or a tuple of strings with the keys of
            the data you want to retrieve. Valid keys are:
            SECT_ID, SECT_NAME, CIS_ID, SECT_TYPE_NUM, SECT_NUM, SECT_SHAPE,
            SECT_SUPERSEDED, SECT_MASS_PER_L, SECT_DEPTH_DIAM, SECT_WIDTH,
            SECT_WEB_THICK, SECT_FLG_THICK, SECT_ROOT_RAD, SECT_TOE_RAD,
            SECT_DEP_FILLET, SECT_SPACE_WEB, SECT_PITCH, SECT_LB_RAT_FLG,
            SECT_LB_RAT_WEB, SECT_END_CLEAR, SECT_NOTCH_LTH, SECT_NOTCH_HGT,
            SECT_GRIP, SECT_FLG_FAST, SECT_SA_PER_L, SECT_SA_PER_M, SECT_C_X,
            SECT_C_Y, SECT_I_XX, SECT_I_YY, SECT_I_UU, SECT_I_VV, SECT_RAD_GYR_XX,
            SECT_RAD_GYR_YY, SECT_RAD_GYR_UU, SECT_RAD_GYR_VV, SECT_RAD_GYR_RT,
            SECT_Z_XX, SECT_Z_YY, SECT_Z_TEE_XX, SECT_Z_FLG_XX, SECT_Z_TOE_XX,
            SECT_ANG_XX2UU, SECT_BUCK_PARAM, SECT_TORS_INDEX, SECT_WARP_CONST,
            SECT_TORS_J, SECT_TORS_C, SECT_AREA, SECT_GROSS_AREA, SECT_L_PER_M,
            SECT_SHEAR_CENT, SECT_ZP_XX, SECT_ZP_WEB_AR, SECT_ZP_XX_WEB,
            SECT_ZP_XX_N, SECT_ZP_XX_K1, SECT_ZP_XX_K2, SECT_ZP_XX_K3,
            SECT_ZP_XX_K4, SECT_ZP_YY, SECT_ZP_YY_N, SECT_ZP_YY_K1,
            SECT_ZP_YY_K2, SECT_ZP_YY_K3, SECT_ZP_YY_K4, SECT_ZP_YY_C1K1,
            SECT_ZP_YY_C1K2, SECT_ZP_YY_C1K3, SECT_ZP_YY_C1K4, SECT_ZP_YY_C1K5,
            SECT_ZP_YY_C1K6, SECT_ZP_YY_C2K1, SECT_ZP_YY_C2K2, SECT_ZP_YY_C2K3,
            SECT_ZP_YY_C2K4, SECT_ZP_YY_C2K5, SECT_ZP_YY_C2K6, SECT_AX_XX,
            FACTOR_CX, FACTOR_CY, SECT_DATE_ADDED

        :return: if a single string is passed to section_info, it returns the value requested,
                 if a tuple of keys is passed to section_info, it returns a tuple of values

        """

        self.gsapy_logging("GSA.get_section_info")

        valid_keys = ["SECT_ID", "SECT_NAME", "CIS_ID", "SECT_TYPE_NUM", "SECT_NUM", "SECT_SHAPE",
            "SECT_SUPERSEDED", "SECT_MASS_PER_L", "SECT_DEPTH_DIAM", "SECT_WIDTH",
            "SECT_WEB_THICK", "SECT_FLG_THICK", "SECT_ROOT_RAD", "SECT_TOE_RAD",
            "SECT_DEP_FILLET", "SECT_SPACE_WEB", "SECT_PITCH", "SECT_LB_RAT_FLG",
            "SECT_LB_RAT_WEB", "SECT_END_CLEAR", "SECT_NOTCH_LTH", "SECT_NOTCH_HGT",
            "SECT_GRIP", "SECT_FLG_FAST", "SECT_SA_PER_L", "SECT_SA_PER_M", "SECT_C_X",
            "SECT_C_Y", "SECT_I_XX", "SECT_I_YY", "SECT_I_UU", "SECT_I_VV", "SECT_RAD_GYR_XX",
            "SECT_RAD_GYR_YY", "SECT_RAD_GYR_UU", "SECT_RAD_GYR_VV", "SECT_RAD_GYR_RT",
            "SECT_Z_XX", "SECT_Z_YY", "SECT_Z_TEE_XX", "SECT_Z_FLG_XX", "SECT_Z_TOE_XX",
            "SECT_ANG_XX2UU", "SECT_BUCK_PARAM", "SECT_TORS_INDEX", "SECT_WARP_CONST",
            "SECT_TORS_J", "SECT_TORS_C", "SECT_AREA", "SECT_GROSS_AREA", "SECT_L_PER_M",
            "SECT_SHEAR_CENT", "SECT_ZP_XX", "SECT_ZP_WEB_AR", "SECT_ZP_XX_WEB",
            "SECT_ZP_XX_N", "SECT_ZP_XX_K1", "SECT_ZP_XX_K2", "SECT_ZP_XX_K3",
            "SECT_ZP_XX_K4", "SECT_ZP_YY", "SECT_ZP_YY_N", "SECT_ZP_YY_K1",
            "SECT_ZP_YY_K2", "SECT_ZP_YY_K3", "SECT_ZP_YY_K4", "SECT_ZP_YY_C1K1",
            "SECT_ZP_YY_C1K2", "SECT_ZP_YY_C1K3", "SECT_ZP_YY_C1K4", "SECT_ZP_YY_C1K5",
            "SECT_ZP_YY_C1K6", "SECT_ZP_YY_C2K1", "SECT_ZP_YY_C2K2", "SECT_ZP_YY_C2K3",
            "SECT_ZP_YY_C2K4", "SECT_ZP_YY_C2K5", "SECT_ZP_YY_C2K6", "SECT_AX_XX",
            "FACTOR_CX", "FACTOR_CY", "SECT_DATE_ADDED"]

        if isinstance(section_info, str):
            section_info = (section_info,)

        for i in section_info:
            if i not in valid_keys:
                raise GSAError(f"{i} is not a valid key.")

        if self.dbpath is None:
            version = search(r"^\d+\.\d+", self.version()).group()
            self.dbpath = rf'C:\Program Files\Oasys\GSA {version}\sectlib.db3'
            self.log.info(f'Setting section database to {self.dbpath}')

        if self.conn is None:
            self.conn = sqlite3.connect(self.dbpath)

        cursor = self.conn.cursor()

        section = self.get(Section)[section_number].desc.split('%')[1:3]
        section_type = (section[0],)
        section_type_num = cursor.execute(
            "select TYPE_NUM from Types where TYPE_ABR=? and TYPE_SUPERSEDED=0",
            section_type).fetchone()[0]

        parameters = (section_type_num, section[1])

        results = cursor.execute(
            f"select {', '.join(section_info)} from Sect where SECT_TYPE_NUM=? AND SECT_NAME=?",
            parameters).fetchall()
        if len(results) != 1:
            raise GSAError("Multiple sections matched")
        if len(results[0]) == 1:
            return results[0][0]
        else:
            return results[0]

    def get_2D_elem_properties(self, index, case):
        '''
        :return tuple of [thickness, bending thickness, in-plane thickness, weight thickness, additional mass]
        '''

        self.gsapy_logging("GSA.get_2D_elem_properties")

        try:
            return [self.get_2D_elem_properties(i, case) for i in index]
        except TypeError:
            results = self._get_2D_elem_results(index, 0, 'default', case, dr.REF_EL_PROP_2DEL, False)
            return tuple(results)

    def get_unit_factors(self):
        '''
        Get the model unit SI conversion factors (e.g. mm would be 1000)

        :return: a dict of factors with keys: FORCE, LENGTH, DISP, SECTION, MASS, TIME, TEMP, STRESS, ACCEL
        '''

        self.gsapy_logging("GSA.get_unit_factors")

        factors = {}
        for key in ['FORCE', 'LENGTH', 'DISP', 'SECTION', 'MASS', 'TIME', 'TEMP', 'STRESS', 'ACCEL']:
            factors[key] = float(self._gwa_command(f'GET, UNIT_DATA.1,{key}')[0][3])

        return factors

    def get_unit_names(self):
        '''
        Get the names of the model units.

        :return: a dict of unit names with keys: FORCE, LENGTH, DISP, SECTION, MASS, TIME, TEMP, STRESS, ACCEL
        '''

        self.gsapy_logging("GSA.get_unit_names")

        names = {}
        for key in ['FORCE', 'LENGTH', 'DISP', 'SECTION', 'MASS', 'TIME', 'TEMP', 'STRESS', 'ACCEL']:
            names[key] = self._gwa_command(f'GET, UNIT_DATA.1,{key}')[0][2]

        return names

    def get_members_connected_to_node(self, index: int):
        '''
        Get the members indices connected to the node

        Raises a GSAError if the node does not exist.

        :param index: index of the node
        :return: list of indices of connected members
        '''
        self.gsapy_logging("GSA.get_members_connected_to_node")
        try:
            result = self.gsa.NodeConnectedEnt(index, EntityEnum.MEMB)
            if result[1] == 0:
                return result[0]
            if result[1] == 1:
                raise GSAError(f"No file open or invalid input")
            if result[1] == 2:
                raise GSAError(f"There is no node number {index}")
        except COMError:
            raise GSAError(f"There is no node number {index}") from None

    def get_elements_connected_to_node(self, index: int):
        '''
        Get the elements indices connected to the node

        Raises a GSAError if the node does not exist.

        :param index: index of the node
        :return: list of indices of connected elements
        '''
        self.gsapy_logging("GSA.get_elements_connected_to_node")
        try:
            result = self.gsa.NodeConnectedEnt(index, EntityEnum.EL)
            if result[1] == 0:
                return result[0]
            if result[1] == 1:
                raise GSAError(f"No file open or invalid input")
            if result[1] == 2:
                raise GSAError(f"There is no node number {index}")
        except COMError:
            raise GSAError(f"There is no node number {index}") from None

    def get_member_length(self, index: int):
        '''
        Get the length of a member

        Raises a GSAError if the member does not exist.

        :param index: index of the member
        :return: length of the member
        '''
        self.gsapy_logging("GSA.get_member_length")
        try:
            return self.gsa.Tool_GetEntLength(index, EntityEnum.MEMB)
        except COMError:
            raise GSAError(f"There is no member number {index}") from None

    def get_element_length(self, index: int):
        '''
        Get the length of an element

        Raises a GSAError if the element does not exist.

        :param index: index of the element
        :return: length of the element
        '''
        self.gsapy_logging("GSA.get_element_length")
        try:
            return self.gsa.Tool_GetEntLength(index, EntityEnum.EL)
        except COMError:
            raise GSAError(f"There is no element number {index}") from None

    def create_elements_from_member(self, index: str):
        '''
        Creates elements from members within GSA

        :param index: index of member

        :return: GSA Return Status
        '''
        self.gsapy_logging("GSA.create_elements_from_member")
        try:
            result = self.gsa.CreateElementsFromMembers(index)
            if result == 0:
                return result
            if result == 1:
                raise GSAError(f"No GSA file is open")
            if result == 2:
                raise GSAError(f"Terminated because model already has results {index}")
            if result == 3:
                raise GSAError(f"Invalid member list {index}")
            if result == 4:
                raise GSAError(f"Completed, but some members had meshing errors (open in GSA for details) {index}")
        except COMError:
            raise GSAError(f"GSA was unable to create elements {index}") from None

    def get_member_from_element(self, index: int):
        ''' Returns the member index associated with the given element
        
        :param index: Index of elements
        :return: the number of the member that contains the element
        '''
        self.gsapy_logging("GSA.get_member_from_element")
        member_number = self.gsa.ElemMembNum(index)
        return member_number

    def _get_number_of_elements_in_member(self, index: int):
        '''


        :returns: the number of elements associated with the given member.
        '''
        try:
            return self.gsa.MembNumElem(index)
        except COMError:
            raise GSAError(f"Member {index} does not exist.") from None

    def get_element_at_member_position(self, index: int, n: int):
        """
        Returns the element index for the given member and element position. This function will raise GSAError if
        the member does not exist. If the index n is out of bounds (either less than zero, or greater than or equal
        to the number of elements in the member), the function returns a random number (because that's what the GSA
        COM API does...

        :param index: index of the member
        :param position_index: sequential postion of the element in the member (first element is 0)
        :return: the index of the nth element in member 'index'
        """
        self.gsapy_logging("GSA.get_element_at_member_position")
        try:
            return self.gsa.MembElemNum(index, n)
        except COMError:
            raise GSAError(f"Member {index} does not exist") from None

    def get_member_element_indices(self, index:int):
        """
        Get a list of the indices of elements included in member 'index'.

        :param index: the index of the member
        :return: a list of the indices of elements in member 'index'
        """
        self.gsapy_logging("GSA.get_member_element_indices")
        return [self.get_element_at_member_position(index,i)
                for i in range(0, self._get_number_of_elements_in_member(index))]

    def update_element_section_from_member(self, index: int):
        '''
        Updated elements section property, based on member section property
        Other attributes are unchanged
        Modifies the elements in GSA and then returns the indicies of the modified elements as a list

        :param index: index of member
        :returns: the indices of the modified elements
        '''
        self.gsapy_logging("GSA.update_element_section_from_member")
        element_indicies = self.get_member_element_indices(index)
        elements = self.get_elements(element_indicies)
        
        section = self.get_members(index).prop

        for element in elements.values():
            element.prop = section
        
        self.set(elements)

        return element_indicies

    def update_all_element_sections_from_members(self):
        '''
        Updates all element sections from member sections
        
        '''
        self.gsapy_logging("GSA.update_all_element_sections_from_members")
        members = self.get_members()
        for member in members:
            self.update_element_section_from_member(member.index)

    def update_member_section_from_element(self, index: int):
        '''
        Updated member section property, based on element section property
        Other attributes are unchanged

        :param index: index of element
        :return: index of member updated
        '''
        self.gsapy_logging("GSA.update_member_section_from_element")
        member_index = self.get_member_from_element(index)
        member = self.get_members(member_index)
        member.prop = self.get_elements(index).prop

        self.set(member)

        return member_index

    def update_all_member_sections_from_elements(self):
        ''' Updates all member sections from the section of the first element in each member.
        'First' is whichever element GSA considers to be at position 0.

        :returns: a dictionary of the members that were updated
        '''
        self.gsapy_logging("GSA.update_all_member_sections_from_elements")
        elements = self.get_elements()
        for element in elements:
            self.update_member_section_from_element(element.index)

        members = self.get_members()
        for index, member in members.items():
            member.section = self.get_elements(self.get_element_at_member_position(index,0)).section

        self.set(members)

        return members

    def check_region(self, index: int = 0):
        '''
        Checks the validity of the region specified by the given index.
        If no index is specified, all meshes from regions are checked.

        :param index: index of the region
        :returns: tuple of errors/warnings:
            [num_errors, num_warnings, [messages]]
        '''
        self.gsapy_logging("GSA.check_region")
        result = self.gsa.Gen_RegionMeshCheck(index)
        if result[3] == 0:
            return result[0:3]
        else:
            return [result[0], result[1],
                list(filter(None, re.sub('\t','', result[2]).split('\n')))]

    def generate_mesh_region(self, index : int = 0):
        '''
        Generates meshes for the region specified by the given index.
        If no index is specified, all meshes from regions are generated.

        Throws an error if unable to mesh region.
        Run check_region() to see errors.

        :param index: index of the region
        '''
        self.gsapy_logging("GSA.generate_mesh_region")
        result = self.gsa.Gen_RegionMeshGen(index)
        if result[3] != 0:
            raise GSAError(f"Unable to generate mesh from region {index}")

    def delete_mesh_region(self, index : int = 0):
        '''
        Deletes meshes for the region specified by the given index.
        If no index is specified, all meshes from regions are deleted.

        :param index: index of the region
        '''
        self.gsapy_logging("GSA.delete_mesh_region")
        result = self.gsa.Gen_RegionMeshDel(index)
        if result != 0:
            raise GSAError(f"Unable to delete mesh from region {index}")

    ##########################################################################
    # Results functions
    ##########################################################################

    def _get_entity_results(self, indices, case: str, axis: str, result_reference: int, num1dpos: int, flags: int):
        '''
        Generic method for getting results of any type. This function is used internally by all other result-getting
        functions.

        From GSA 9.0 documentation:

        :param indices: Entity index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
            which results should be extracted; examples of valid entries:
            - "default" 
            - the default for the data being extracted
            - "global"
            - "local"
        :param result_reference: Integer reference for the desired output quantity; result references are attributes
            of the gsapy.output_dataref module, which can also be referred to by variable dr in this package.
            For example, the node reaction output reference is self.output_dataref.REF_REAC, alternatively dr.REF_REAC.
            The reference outside of this module is gsapy.output_dataref.REF_REAC.
        :param flags: compound flag; flags are attributes of gsa.Output_Init_Flags, and can be summed together.
            For example, to output 2D stresses at bottom layer the flag is self.Output_Init_Flags.OP_INIT_2D_BOTTOM.
            The flag outside of this module is gsapy.Output_Init_Flags.OP_INIT_2D_BOTTOM.
            Valid flags are:

            - OP_INIT_2D_BOTTOM = & H1                output 2D stresses at bottom layer
            - OP_INIT_2D_MIDDLE = & H2                output 2D stresses at middle layer
            - OP_INIT_2D_TOP = & H4                   output 2D stresses at top layer
            - OP_INIT_2D_BENDING = & H8               output 2D stresses at bending layer
            - OP_INIT_2D_AVGE = & H10                 average 2D element stresses at nodes
            - OP_INIT_1D_AUTO_PTS = & H20             calculate 1D results at interesting points
            - OP_INIT_INFINITY = & H40                return infinity and NaN values as such, else as zero
            - OP_INIT_1D_WALL_RES_SECONDARY = & H80   output secondary stick of wall equivalent beam results, else primary

            E.g.OP_INIT_2D_TOP Or OP_INIT_2D_AVGE       2D stresses at top layer, averaged at nodes
        :param num1dpos: the number of equidistant internal positions (integer) to be considered for 1D element results,
                         in addition to the automatic interesting positions if specified in flags

        :returns results: A tuple of results, or, if there is only one result, that result alone
        '''
        err_str = "Could not get result for entity {}, case {}, result reference {}: {}."
        try:
            result_init = self.gsa.Output_Init_Arr(flags, axis, case, result_reference, num1dpos)
            if result_init:
                errors = {0: "No error", 1: "No GSA file is open",
                          3: "invalid axis", 4: "invalid case", 5: "invalid result reference"}
                raise GSAError(err_str.format(indices, case, result_reference, errors[result_init]))
            gsa_results, num_components, _ = self.gsa.Output_Extract_Arr(indices)
            if len(gsa_results) == 1:
                # Return a single item
                return gsa_results[0].dynaResults[0]
            else:
                return list(map(lambda x: x.dynaResults[0], gsa_results))
        except COMError as e:
            try:
                self.validate_case(case)
            except GSAError as g:
                raise GSAError(err_str.format(indices, case, result_reference, 'the result case is not valid'))
            if not self.gsa.Output_DataExist(indices):
                raise GSAError(err_str.format(indices, case, result_reference, 'result does not exist for this entity'))
            raise e

    def get_node_reactions(self, index: int, case: str, axis='default'):
        '''
        :param index: Node index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                     which results should be extracted.

        :return: tuple of reactions [FX, FY, FZ, MX, MY, MZ]
        '''
        self.gsapy_logging("GSA.get_node_reactions")
        try:
            return [self.get_node_reactions(i, case, axis) for i in index]
        except TypeError:
            results = self._get_entity_results(index, case, axis, dr.REF_REAC, 0, 0)
            return_indices = [0, 1, 2, 4, 5, 6]
            return tuple(results[ri] for ri in return_indices)

    def get_node_displacements(self, index: int, case: str, axis='default'):
        '''
        :param index: Node index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                    which results should be extracted.

        :return: tuple of displacements [DX, DY, DZ, RX, RY, RZ]
        '''
        self.gsapy_logging("GSA.get_node_displacements")
        try:
            return [self.get_node_displacements(i, case, axis) for i in index]
        except TypeError:
            try:
                results = self._get_entity_results(index, case, axis, dr.REF_DISP, 0, 0)
                return_indices = [0, 1, 2, 4, 5, 6]
                return tuple(results[ri] for ri in return_indices)
            except GSAError:
                # If the node is fully restrained it is not currently returning a displacement
                # This checks if this is the case and returns 0 displacement in this case
                # Im not sure what the behaviour is if only some degrees of freedom are restrained
                node = self.get_nodes(index)
                if node.restraints == [True, True, True, True, True, True]:
                    return (0,0,0,0,0,0)
                else:
                    raise
    
    def _check_entity_type(self, index:int, entity_types:List=None):
        '''
        Check that entity with given index has type in the type list, returns None if true and raises error if not.

        :param index:
        :param entity_types:

        :return:
        '''
        if entity_types:
            index_entity_type = self.get(Element, index).type
            if index_entity_type in entity_types:
                return None
            else:
                err_str = "Element with index {} is not of the correct type, its type is {} but should be one of " \
                          "{} for use with this function."
                raise GSAError(err_str.format(index, index_entity_type,
                                              ', '.join(entity_types)))
        else:
            return None

    def get_member_results(self, index: int, case: str, axis='default'):
        '''
        Returns utilization percentages

        :param index: Member index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                     which results should be extracted.
        :return: tuple of results:
            [overall, local_combined, buckling,
            local_axial, local_su, local_sv, local_torsion, local_muu, local_mvv
            buckling_uu, buckling_vv, buckling_lt, buckling_torsion, buckling_ft]
            TODO: Not sure what the last index is
        '''
        self.gsapy_logging("GSA.get_member_results")
        try:
            return [self.get_member_results(i, case, axis) for i in index]
        except TypeError:
            results = self._get_entity_results(index, case, axis, dr.REF_STL_UTIL, 0, 0)

            return_indices = [i for i in range (14)]
            try:
                return tuple(results[ri] for ri in return_indices)
            except IndexError as ie:
                log.debug(f'could not extract results from {results}')
                raise ie


    # Entity types for 1D result types
    _entity_types_1D_all = ['BEAM', 'BAR', 'ROD', 'SPRING', 'TIE', 'STRUT', 'LINK', 'CABLE', 'DAMPER', 'SPACER']
    _entity_types_1D_section = ['BEAM', 'BAR', 'ROD', 'TIE', 'STRUT']

    def _get_1D_elem_results(self, index, case, axis: str, result_reference, addl_pts, interesting_pts, entity_types):
        '''
        Adds definition of additional points and constructs the interesting points flag
        '''
        if interesting_pts:
            flags = self.Output_Init_Flags.OP_INIT_1D_AUTO_PTS
        else:
            flags = 0
        self._check_entity_type(index, entity_types)
        return self._get_entity_results(index, case, axis, result_reference, addl_pts, flags)

    def get_1D_elem_resultants(self, index, case, axis='default', addl_pts=0, interesting_pts: bool = False):
        '''
        Returns a list of 6-item lists in the form(Fx, Fy, Fz, Mxx, Myy, Mzz).Each set of forces are the forces at a
        point on the specificed element (specified by element number) for the given case
        (specified by 'A12' or 'C2', for example).

        :param index: 1D element index or iterator of indices
        :param case: string describing the case for which you want to extract displacements.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis.
        :param addl_pts: the number of additional points to get results for
        :param interesting_pts: whether or not to return additional interesting points.

        :return: tuple of section forces and moments at the beam end points, as well as additional intermediate points and
                 interesting points. Each section has resultant components [Fx, Fy, Fz, Mxx, Myy, Mzz].
        '''
        self.gsapy_logging("GSA.get_1D_elem_resultants")
        try:
            return [self.get_1D_elem_resultants(i, case, axis, addl_pts, interesting_pts) for i in index]
        except TypeError:
            results_full = self._get_1D_elem_results(index, case, axis, dr.REF_FORCE_EL1D, addl_pts, interesting_pts,
                                                     self._entity_types_1D_all)
            return_indices = [0, 1, 2, 4, 5, 6]
            return [tuple(result[ri] for ri in return_indices) for result in results_full]

    def get_1D_elem_stresses(self, index, case, axis='default', addl_pts=0, interesting_pts: bool = False):
        '''
        Only applies to 1D elements that have a section property attribute.

        :param index: 1D element index or iterator of indices
        :param case: string describing the case for which you want to extract displacements.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis.
        :param addl_pts: the number of additional points to get results for.
        :param interesting_pts: whether or not to return additional interesting points.
        :return: tuple of section stresses at beam end points, as well as additional intermediate points and
                 interesting points. Each section has stress components [S(Axial), S(Shear-y), S(Shear-z),
                 S(Bending +z), S(Bending -z), S(Bending +y), S(Bending -y),
                 S(Combined 1), S(Combined 2), S(Combined y), S(Combined z)]
        '''
        self.gsapy_logging("GSA.get_1D_elem_stresses")
        try:
            return [self.get_1D_elem_stresses(i, case, axis, addl_pts, interesting_pts) for i in index]
        except TypeError:
            return self._get_1D_elem_results(index, case, axis, dr.REF_STRESS_EL1D, addl_pts, interesting_pts,
                                             self._entity_types_1D_section)

    def get_1D_elem_displacements(self, index, case, axis='default', addl_pts=0, interesting_pts: bool = False):
        '''
        Returns section displacements at various points along the 1D element(specified by element number) for the
        given case (specified by 'A12' or 'C2', for example).

        :param index: 1D element index or iterator of indices
        :param case: string describing the case for which you want to extract displacements.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis.
        :param addl_pts: the number of additional points to get results for
        :param interesting_pts: whether or not to return additional interesting points.

        :return: tuple of section displacements and rotations at the beam end points, as well as additional intermediate points and
                 interesting points. Each section has resultant components [DX, DY, DZ, RXX, RYY, RZZ].
        '''
        self.gsapy_logging("GSA.get_1D_elem_displacements")
        try:
            return [self.get_1D_elem_displacements(i, case, axis, addl_pts, interesting_pts) for i in index]
        except TypeError:
            results_full = self._get_1D_elem_results(index, case, axis, dr.REF_DISP_EL1D, addl_pts, interesting_pts,
                                                     self._entity_types_1D_all)
            return_indices = [0, 1, 2, 4, 5, 6]
            return [tuple(result[ri] for ri in return_indices) for result in results_full]

    def get_1D_elem_strains(self, index, case, axis='default', addl_pts=0, interesting_pts: bool = False):
        '''
        Returns section axial strains at various points along the 1D element(specified by element number) for the
        given case (specified by 'A12' or 'C2', for example).

        :param index: 1D element index or iterator of indices
        :param case: string describing the case for which you want to extract displacements.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis.
        :param addl_pts: the number of additional points to get results for
        :param interesting_pts: whether or not to return additional interesting points.

        :return: tuple of section axial strains and rotations at the beam end points, as well as additional intermediate points and
                  interesting points.
        '''
        self.gsapy_logging("GSA.get_1D_elem_strains")
        try:
            return [self.get_1D_elem_strains(i, case, axis, addl_pts, interesting_pts) for i in index]
        except TypeError:
            return self._get_1D_elem_results(index, case, axis, dr.REF_STRAIN_EL1D, addl_pts, interesting_pts,
                                             self._entity_types_1D_section)

    def _get_2D_elem_results(self, index, flags, axis, case, result_reference, averaged: bool):
        entity_types = ['QUAD4', 'QUAD8', 'TRI3', 'TRI6']
        if averaged:
            flags += self.Output_Init_Flags.OP_INIT_2D_AVGE
        self._check_entity_type(index, entity_types)
        return self._get_entity_results(index, case, axis, result_reference, 0, flags)

    def get_2D_elem_forces(self, index, case, axis='default', averaged: bool = False):
        '''
        :param index: 2D element index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                     which results should be extracted.
        :param averaged: averaged: whether or not results should be averaged.
        :return: tuple of forces [NX, NY, NXY, QX, QY]
        '''
        self.gsapy_logging("GSA.get_2D_elem_forces")
        try:
            return [self.get_2D_elem_forces(i, case, axis, averaged) for i in index]
        except TypeError:
            results_full = self._get_2D_elem_results(index, 0, axis, case, dr.REF_FORCE_EL2D_PRJ, averaged)
            return_indices = range(2, 7)
            return [tuple(result[ri] for ri in return_indices) for result in results_full]

    def get_2D_elem_moments(self, index, case, axis='default', averaged: bool = False):
        '''
        :param index: 2D element index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                     which results should be extracted.
        :param averaged: averaged: whether or not results should be averaged.
        :return: tuple of moments [MX, MY, MXY, \|MX + MXY\|, \|MY + MXY\|]
        '''
        self.gsapy_logging("GSA.get_2D_elem_moments")
        try:
            return [self.get_2D_elem_moments(i, case, axis, averaged) for i in index]
        except TypeError:
            results_full = self._get_2D_elem_results(index, 0, axis, case, dr.REF_MOMENT_EL2D_PRJ, averaged)
            return_indices = range(1, 6)
            return [tuple(result[ri] for ri in return_indices) for result in results_full]

    def get_2D_elem_resultants(self, index, case, axis='default', averaged: bool = False):
        '''
        :param index: 2D element index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                     which results should be extracted.
        :param averaged: whether or not results should be averaged.

        :return: tuple of forces and moments [NX, NY, NXY, QX, QY, MX, MY, MXY, \|MX + MXY\|, \|MY + MXY\|]
        '''
        self.gsapy_logging("GSA.get_2D_elem_resultants")
        try:
            return [self.get_2D_elem_resultants(i, case, axis, averaged) for i in index]
        except TypeError:
            forces = self.get_2D_elem_forces(index, case, axis, averaged)
            moments = self.get_2D_elem_moments(index, case, axis, averaged)
            return [force + moment for force, moment in zip(forces, moments)]

    def get_2D_elem_displacements(self, index, case, axis='default', averaged: bool = False):
        '''
        :param index: 2D element index or iterator of indices
        :param case: A string describing the case for which you want to extract results.
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                    which results should be extracted.
        :param averaged: averaged: whether or not results should be averaged.

        :return: tuple of displacements [DX, DY, DZ]
        '''
        self.gsapy_logging("GSA.get_2D_elem_displacements")
        try:
            return [self.get_2D_elem_displacements(i, case, axis, averaged) for i in index]
        except TypeError:
            results_full = self._get_2D_elem_results(index, 0, axis, case, dr.REF_DISP_EL2D, averaged)
            return_indices = [0, 1, 2]
            return [tuple(result[ri] for ri in return_indices) for result in results_full]

    def get_2D_elem_stresses(self, index, case, axis='default', position='middle', averaged: bool = False):
        '''
        :param index: 2D element index or iterator of indices
        :param case: Result case
        :param axis: either 'global', 'local', 'default' or the number of a user defined axis, axis with respect to
                     which results should be extracted.
        :param position: 'middle', 'bottom' or 'top', section location (with regards to positive z axis) at which results
                          are extracted.
        :param averaged: whether or not results should be averaged.

        :return: tuple of stresses [SXX SXY SYY SYZ SZX SZZ]
        '''
        self.gsapy_logging("GSA.get_2D_elem_stresses")
        try:
            return [self.get_2D_elem_stresses(i, case, axis, position, averaged) for i in index]
        except TypeError:
            if position == 'middle':
                flags = self.Output_Init_Flags.OP_INIT_2D_MIDDLE
            elif position == 'top':
                flags = self.Output_Init_Flags.OP_INIT_2D_TOP
            elif position == 'bottom':
                flags = self.Output_Init_Flags.OP_INIT_2D_BOTTOM
            elif position == 'bending':
                flags = self.Output_Init_Flags.OP_INIT_2D_BENDING
            else:
                raise GSAError('Invalid position for 2D result ')
            return self._get_2D_elem_results(index, flags, axis, case, dr.REF_STRESS_EL2D_PRJ, averaged)

    #####
    # Old
    #####

    # def get_node_displacements(self, node, case, axis='default'):
    #     """
    #     Get displacements at a given node.
    #
    #     :param node: the number of the node to get displacements for
    #     :param case: A string describing the case for which you want to extract displacements.
    #     :param axis: either 'global', 'local', 'default' or the number of a user defined axis
    #     :return:
    #     """
    #     #        (case_type, case_number) = self.validate_case(case)
    #
    #     results = []
    #
    #     dresult = self.gsa.Output_Init_Arr(0, axis, case, dr.REF_DISP, 0)
    #
    #     if dresult == 0:
    #         disp = self.gsa.Output_Extract_Arr(node)[0]
    #         dindices = [0, 1, 2, 3, 4, 5, 6, 7]
    #         for d in disp:
    #             results.append([d.dynaResults[0][a] for a in dindices])
    #     else:
    #         m = {0: "No error", 1: "No GSA file is open",
    #              3: "invalid axis", 4: "invalid case", 5: "invalid dataref"}
    #         raise GSAError(
    #             "Could not get results -- displacement {}.".format(m[dresult]))
    #
    #     return results
    #
    def get_spring_forces(self, node, case, axis='default'):
        """
        This is a deprecated wrapper for get_node_reactions. Use get_reactions instead.

        """
        log.warning("get_spring_forces is deprecated. Use get_reactions instead.")
        self.get_node_reactions(node, case, axis)

    #
    # def get_reactions(self, node, case, axis='default'):
    #     """s
    #     Get nodal reactions.
    #
    #     :param node: the node to get reactions at (an integer)
    #     :param case: A string describing the case for which you want to extract displacements.
    #     :param axis: either 'global', 'local', 'default' or the number of a user defined axis
    #     :return: a list of six forces: [Fx, Fy, Fz, Mxx, Myy, Mzz]
    #     """
    #     #        (case_type, case_number) = self.validate_case(case)
    #
    #     results = []
    #     fresult = self.gsa.Output_Init_Arr(0, axis, case, dr.REF_REAC, 0)
    #
    #     if fresult == 0:
    #         forces = self.gsa.Output_Extract_Arr(node)[0]
    #         findices = [0, 1, 2, 4, 5, 6]
    #         for f in forces:
    #             results.append([f.dynaResults[0][a] for a in findices])
    #     else:
    #         m = {0: "No error", 1: "No GSA file is open",
    #              3: "invalid axis", 4: "invalid case", 5: "invalid dataref"}
    #         raise GSAError(
    #             "Could not get results -- forces {}.".format(m[fresult]))
    #
    #     return results
    #
    # def get_2D_elem_forces(self, element_index, case, axis='default'):
    #     """
    #     Get 2D elements forces.
    #     :param element_index: the index of the element to get results for (an integer)
    #     :param case: A string describing the case for which you want to extract displacements.
    #     :param axis: either 'global', 'local', 'default' or the number of a user defined axis
    #     :return: a list of 10 results [Mx, My, Mxy, |Mx+Mxy|, |My+Mxy|, Nx, Ny, Nxy, Qx, Qy]
    #     """
    #     element = self.get_elements(element_index)
    #     t = element.type
    #     if t != 'QUAD4' and t != 'QUAD8' and t != 'TRI3' and t != 'TRI6':
    #         raise ValueError("Element " + str(element_index) +
    #                          " is a " + t + ". It must be a QUAD or TRI.")
    #
    #     # (case_type, case_number) = self.validate_case(case)
    #
    #     results = []
    #
    #     mresult = self.gsa.Output_Init_Arr(
    #         0, axis, case, dr.REF_MOMENT_EL2D_PRJ, 0)
    #     moments = self.gsa.Output_Extract_Arr(element_index)[0]
    #
    #     fresult = self.gsa.Output_Init_Arr(
    #         0, axis, case, dr.REF_FORCE_EL2D_PRJ, 0)
    #     forces = self.gsa.Output_Extract_Arr(element_index)[0]
    #
    #     if mresult == 0 and fresult == 0:
    #         mindices = [1, 2, 3, 4, 5]
    #         findices = [2, 3, 4, 5, 6]
    #         for (m, f) in zip(moments, forces):
    #             results.append([m.dynaResults[0][a] for a in mindices] +
    #                            [f.dynaResults[0][a] for a in findices])
    #     else:
    #         m = {0: "No error", 1: "No GSA file is open",
    #              3: "invalid axis", 4: "invalid case", 5: "invalid dataref"}
    #         raise GSAError(
    #             "Could not get results -- moments: {} , forces {}.".format(m[mresult], m[fresult]))
    #
    #     return results
    #
    # def get_beam_forces(self, element_index, case, axis='default', addl_pts=0):
    #     """
    #     Returns a list of 6-item lists in the form (Fx, Fy, Fz, Mxx, Myy, Mzz). Each set of forces are the forces at a point
    #     on the specificed element (specified by element number) for the given case (specified by 'A12' or 'C2', for example).
    #
    #     :param element: the index of the element to get results for (an integer)
    #     :param case: A string describing the case for which you want to extract displacements.
    #     :param axis: either 'global', 'local', 'default' or the number of a user defined axis
    #     :param addl_pts: the number of additional points to get results for
    #     :return: a list of lists of section forces. Each list of section forces has [Fx, Fy, Fz, Mxx, Myy, Mzz].
    #     """
    #     element = self.get_elements(element_index)
    #     if element.type != 'BEAM':
    #         raise GSAError("Element " + element + " is not a beam.")
    #
    #     # (case_type, case_number) = self.validate_case(case)
    #     hresult = self.gsa.Output_Init_Arr(
    #         GSA.Output_Init_Flags.OP_INIT_1D_AUTO_PTS,
    #         axis,
    #         case,
    #         dr.REF_FORCE_EL1D,
    #         addl_pts)
    #     if hresult == 0:
    #         force_indices = [0, 1, 2, 4, 5, 6]
    #         results = []
    #         for r in self.gsa.Output_Extract_Arr(element_index)[0]:
    #             results.append([r.dynaResults[0][a] for a in force_indices])
    #             # results.append (  r.dynaResults[0])
    #         # return [ [r[0][0].dynaResults[0][a] for a in force_indices],
    #         # [r[0][1].dynaResults[0][a] for a in force_indices ] ]
    #         return results
    #     else:
    #         m = {1: "No GSA file is open", 3: "invalid axis",
    #              4: "invalid case", 5: "invalid dataref"}
    #         raise GSAError("Could not get results -- {}".format(m[hresult]))

    def get_assembly_forces(self, assembly, case):
        """
        This function returns a list of lists. Each element in the first list is a list with 7 items. The first of the
        seven items is the position along the assembly at with the forces are cut. The next six items are
        the section forces: Fx, Fy, Fz, Mxx, Myy, Mzz.

        :param assembly: the index of the assembly to get results for.
        :param case: A string describing the case for which you want to extract displacements.

        :return: a list of lists of results. Each list is of the form [position, Fx, Fy, Fz, Mxx, Myy, Mzz].
        """
        # (case_type, case_number) = self.validate_case(case)

        self.gsapy_logging("GSA.get_assembly_forces")
        if not self._gwa_command(f"EXIST,ASSEMBLY,{assembly}"):
            raise GSAError(f"Assembly {assembly} does not exist.")

        hresult = self.gsa.Output_Init_Arr(
            GSA.Output_Init_Flags.OP_INIT_1D_AUTO_PTS,
            'default',
            case,
            dr.REF_FORCE_EL1D,
            0)
        if hresult == 0:
            results = []
            for r in self.gsa.Output_Extract_CutAssembly(
                    assembly, False, case, 'default', )[0]:
                results.append([r.Pos] + list(r.dynaResults[0]))
            return results
        else:
            m = {1: "No GSA file is open", 3: "invalid axis",
                 4: "invalid case", 5: "invalid dataref"}
            raise GSAError(f"Could not get results --  {m[hresult]}.")

    def highest_entity(self, module_cls):
        '''
        Find the highest number for a given entity (NODE, ELEMENT, etc...)

        :param module_cls: gsapy module class
        :return: Highest number in record (integer)
        '''
        self.gsapy_logging("GSA.highest_entity")
        return self._gwa_command(f'Highest\t{module_cls._module_name}')

    # TODO
    # def lowest_entity(self, module_cls):
    #     '''
    #     :param module_cls: gsapy module class
    #     :return: Lowest number in record
    #     '''
    #     return self.gwa_command('')

    def number(self, entity_cls):
        """
        Find out how many of a given entity (NODE, ELEMENT, etc..)

        :param entity_cls: the class of the entity to check for e.g. gsapy.Node
        :return: the number of entities in the model
        """
        self.gsapy_logging("GSA.number")
        entities_list = self._gwa_command(
            f'GET_ALL\t{entity_cls._module_name}')
        return len(entities_list)

    def renumber(self, unit_data, old_ref, new_ref):
        '''
        Renumber of data item. This only works for NODE, ELEMENT, MEMBER, LINE, AREA, REGION.

        :param unit_data: string describing the type of data (e.g. 'NODE')
        :param old_ref: current index (integer)
        :param new_ref: new index (integer)
        '''
        self.gsapy_logging("GSA.renumber")
        entity = EntityEnum[unit_data]
        #        print(type(entity), entity)
        #        print(type(old_ref))
        #        print(type(new_ref))

        result = self.gsa.Renumber_Init(entity)
        if result == 0:
            try:
                result = self.gsa.Renumber_SetTo(entity, old_ref, new_ref)
                if result != 0:
                    raise GSAError(
                        f"Could not renumber {unit_data} {old_ref} to {new_ref}"
                    )
            except BaseException:
                raise GSAError(
                    f"Could not set {unit_data} {old_ref} to {new_ref} -- COM could not initialise renumbering."
                )

        if result == 0:
            result = self.gsa.Renumber_Go(entity)
        if result != 0:
            m = {1: "No GSA file is open",
                 2: "Renumber_Init not called for this option"}
            raise GSAError(f"Could not get results --  {m[result]}.")

        return result

    def gwa_command(self, command):
        """
        Executes a GWA command on the open model.

        :param command: a comma or tab delimited string with the GWA command
        :return: the results of the GWA, converted to a list
        """
        self.gsapy_logging("GSA.gwa_command")
        return self._gwa_command(command)

    def _gwa_command(self, command):
        """
        Executes a GWA command on the open model - this is the internal version used by other gsapy commands,
        to avoid logging a bazillion calls.

        :param command: a comma or tab delimited string with the GWA command
        :return: the results of the GWA, converted to a list
        """
        # TODO: GwaComman not working for AnalysisTasks. 'r' always comes back /
        #  as 0. This causes GSAError in '_set_one_' function
        r = self.gsa.GwaCommand(command)
        if isinstance(r, str):
            if "\t" in r:
                return [i.split("\t") for i in r.splitlines()]
            else:
                return list(csv.reader(r.splitlines()))
        else:
            return r

    def analyse(self, task=None):
        """
        Run analysis tasks.

        :param task: the index (integer) of the task to analyse, set to None to analyse all tasks
        :raise: GSAError if the analysis can't be carried out
        """
        self.gsapy_logging("GSA.analyse")
        if task is None:
            # Analyse all tasks
            self.log.debug(f"Trying to analyse all tasks")
            r = self.gsa.Analyse(-1)
            self.log.debug(f"Analyse all task result code: {r}")
            if r != 0:
                messages = {1: "no GSA file is open",
                            2: "failed to attempt analysis"}
                raise GSAError(
                    f"Could not analyse tasks: {messages[r]}."
                )
        else:
            tasks_to_analyse = [task]

            for t in tasks_to_analyse:
                self.log.debug(f"Trying to analyse task {t}")
                if self.gsa.TaskStatus(t) == 3:
                    r = self.gsa.Analyse(t)
                    self.log.debug(f"Task {t} result code: {r}")
                    if r != 0:
                        messages = {1: "no GSA file is open",
                                    2: "failed to attempt analysis"}
                        raise GSAError(
                            f"Could not analyse task {t}: {messages[r]}."
                        )

                    task_status = self.gsa.TaskStatus(t)
                    self.log.debug(
                        f"After analysis of task {t}, status is {task_status}."
                    )
                    if task_status != 0:
                        messages = {1: "no GSA file is open",
                                    2: "task does not exist", 3: "analysis failed"}
                        raise GSAError(f"Could not analyse task {t}: {messages[task_status]}.")
        return

    def design(self, task=None, option='check'):
        """
        Runs the specified design task or all tasks. This function raises a GSAError on the first task
        that cannot be designed.
        
        :param task:  the number of the Design task to be executed. set to None to check all tasks.
        :param option: runs task as check or design, can be 'check' (default) or 'design'.
        """
        self.gsapy_logging("GSA.design")

        if task is None:
            tasks_to_design = [int(t[1]) for t in self._gwa_command(f'GET_ALL\tDESIGN_TASK')]
        else:
            tasks_to_design = [task]

        self.log.debug(f"Design tasks: {tasks_to_design}")

        for t in tasks_to_design:
            self.log.debug(f"Ready to {option} task {t}, current status is {self.gsa.DesignTaskStatus(t)}")
            r = self.gsa.Design(t, 1 if option == 'design' else 0)
            if (r != 0):
                messages = {1: "no GSA file open",
                            2: "design task does not exist",
                            3: "design task has results"}
                raise GSAError(
                    f"Could not {option} task {t}: {messages[r]}."
                )

            task_status = self.gsa.DesignTaskStatus(t)
            self.log.debug(f"After {option} of task {t}, status is {task_status}.")

            if task_status != 3:
                messages = {1: "no file open",
                            2: "design task does not exist",
                            3: "design task has results",
                            4: "design task has not been designed or checked"}
                raise GSAError(f"Could not {option} task {t}: {messages[task_status]}.")

    def delete_results(self):
        '''
        Deletes analysis results.

        :return: Nothing
        '''
        self.gsapy_logging("GSA.delete_results")
        h = self.gsa.delete('RESULTS')
        if h == 1:
            raise GSAError("No GSA file open.")

    def __init__(self, path=None, version=None):
        '''
        Create a new GSA object. This is the starting point for gsapy.

        :param path: the path to your gsa file. It can be absolute, or relative to the working directory.
        :param version: GSA version string in the format "X.X" (e.g. "10.0")
        '''

        self.log = logging.getLogger(__name__)
        self.log.info(f"Initializing GSA object with path: {path} and version: {version}")
        self.gsa = None

        if (path is not None) and (version is None):
            version = check_file_version(path)

        if version is None:
            self.gsa = CreateObject("Gsa.ComAuto", CLSCTX_LOCAL_SERVER)
        else:
            versions = fullmatch("(\d+)\.(\d)", version)
            if versions is None:
                raise GSAError(
                    f"{version} is not a valid GSA version.")
            (major, minor) = versions.group(1, 2)
            try:
                self.gsa = CreateObject(f"Gsa_{major}_{minor}.ComAuto", CLSCTX_LOCAL_SERVER)
            except OSError as ose:
                raise GSAError(f"GSA Version {version} is not installed or registered on this computer.") from ose

        structs.initialize(self.gsa.__com_interface__.__module__)

        feature_description = f"gsapy::{__version__}"
        self.log.info(feature_description)
        if self.gsa.LogFeatureUsage(feature_description) != 0:
            self.log.info("Could not log gsapy usage")

        self.dbpath = None

        self.conn = None

        if path is None:
            hresult = self.gsa.NewFile()
            if hresult != 0:
                raise GSAError("Could not create new file.")
        else:
            self.open(path)

    def open(self, path):
        """
        Open a new GSA file with the same GSA instance

        :param path: the path to your gsa file. It can be absolute, or relative to the working directory.
        """
        self.gsapy_logging("GSA.open")
        full_path = abspath(path)
        if exists(full_path):
            hresult = self.gsa.Open(abspath(path))
            if hresult != 0:
                raise GSAError(f"Could not open {full_path}")
        else:
            hresult = self.gsa.NewFile()
            if hresult != 0:
                raise GSAError("Could not create new file.")

            self.save_as(full_path)

    def save(self):
        """
        Save changes to the open GSA file.
        """
        r = self.gsa.Save()
        if r != 0:
            m = {
                1: "no GSA file open",
                2: "no default path is available; use saveas()",
                3: "failed to save"}
            raise GSAError(f"Could not save file {m[r]} .")

    def save_as(self, path):
        """
        Save the GSA file as a new file.

        :param path: the path to the new gsa file. It can be absolute, or relative to the working directory.
        """
        self.gsapy_logging("GSA.save_as")
        r = self.gsa.SaveAs(abspath(path))
        if r != 0:
            m = {
                1: "no GSA file open",
                2: "no default path is available; use saveas()",
                3: "failed to save"}
            raise GSAError(f"Could not save file {m[r]} .")

    def close(self):
        """
        Close the open GSA file.

        """
        if self.gsa is not None:
            self.gsa.Close()
            self.gsa = None
        if self.conn is not None:
            self.conn.close()
            self.conn = None

    # TODO figure out relationship between open, init, enter
    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def __del__(self):
        self.close()

    def version(self):
        """
        Get the version number of the currently running GSA as a string.

        :return: the version of the current instance of GSA (string)
        """
        self.gsapy_logging("GSA.version")
        return search("[\d\.]+", self.gsa.VersionString()).group()

    def version_string(self):
        """
        Get the full version string as reported directly by GSA.

        :return: the versions of the current instance of GSA and all associated plugins (string)
        """
        self.gsapy_logging("GSA.version_string")
        result = self.gsa.VersionString()
        return result

    def num_arg(self, line):
        """
        Count the number of arguments in a GWA command. Please don't use this, we've only provided it for compatibility
        with the underlying GSA COM interface.

        :param line: a string of comma separated or tab separated arguments (string)
        :return: the number of arguments in the given line (integer)
        """
        if isinstance(line, str):
            try:
                sniffer = csv.Sniffer()
                delimiter = sniffer.sniff(line).delimiter
                result = len(line.split(delimiter))
            except csv.Error as m:
                raise GSAError(str(m)) from None
        else:
            raise ValueError("Argument must be a string.")
        return result

    def arg(self, index, line):
        """
        Return a particular argument of a GWA Command. Please don't use this, we've only provided it for compatibility
        with the underlying GSA COM interface.

        :param index: an index position in the line (integer)
        :param line: a string of comma separated or tab separated arguments (string)
        :return: the argument at the given index position in the line (string)
        """
        if not isinstance(index, int):
            raise ValueError("First argument must be an integer")

        if isinstance(line, str):
            raise ValueError("Second argument must be a string")

        try:
            sniffer = csv.Sniffer()
            delimiter = sniffer.sniff(line).delimiter
            result = line.split(delimiter)
            if index > len(result):
                raise IndexError(
                    f"You requested argument {index}, but the only has {len(result)} arguments. (Index is zero based)")
        except csv.Error as m:
            raise csv.Error(f"{m}.")

        return result[index].strip()


    def set_locale(self, option=LocaleEnum.LOC_SYSTEM):
        """
        Set the locale of the GSA model. Defaults to the local system locale.

        :param option: the locale setting for parsing GwaCommand strings, from the LocaleEnum class (enumeration)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.set_locale")
        hresult = self.gsa.SetLocale(option)
        if hresult == 1:
            raise GSAError(
                "Could not get set locale -- invalid locale specified")
        return hresult

    # View Functions

    def update_views(self):
        """
        Update the saved views.
        """
        #TODO: error checking?
        self.gsapy_logging("GSA.update_views")
        self.gsa.UpdateViews()


    def print_all_views(self, option=batch_view_options.ALL_SGV):
        """
        Print all the saved graphics views, using the printer setup options specified in GSA.

        :param option: a setting for specifying the type of view to be batch printed, from the batch_view_options namedtuple (string)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.print_all_views")
        expected_options = [
            "ALL_PGV",
            "ALL_SGV",
            "ALL_POV",
            "ALL_SOV",
            "ALL_LST",
            "TAGGED_PGV",
            "TAGGED_SGV",
            "TAGGED_POV",
            "TAGGED_SOV",
            "TAGGED_LST"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple batch_view_options)"
            )
        hresult = self.gsa.printView(option)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "invalid argument"}
            raise GSAError(f"Could not print view -- {m[hresult]} .")
        return hresult

    def print_view(self, view_name):
        """
        Print a single view, using the Printer Setup options specified in GSA.

        :param view_name: the name of view or view list (string)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.print_view")
        hresult = self.gsa.printView(view_name)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "invalid argument"}
            raise GSAError(f"Could not print view -- {m[hresult]} .")
        return hresult

    def save_all_views_to_file(self, option=batch_view_options.ALL_SGV, file_type=file_type_options.JPG):
        """
        Save all saved graphic views to file.

        :param option: a setting for specifying the type of view to be batch saved, from the batch_view_options namedtuple (string)
        :param file_type: the type of file that the views will saved as, from the file_type_options namedtuple (string)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.save_all_views_to_file")
        expected_options = [
            "ALL_PGV",
            "ALL_SGV",
            "ALL_POV",
            "ALL_SOV",
            "ALL_LST",
            "TAGGED_PGV",
            "TAGGED_SGV",
            "TAGGED_POV",
            "TAGGED_SOV",
            "TAGGED_LST"]
        expected_file_type = ["WMF", "PNG", "JPG", "TXT", "CSV", "HTM"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple batch_view_options)"
            )
        elif file_type.upper() not in (item.upper() for item in expected_file_type):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_file_type)}. (See namedtuple file_type_options)"
            )
        hresult = self.gsa.SaveViewToFile(option, file_type)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "invalid argument"}
            raise GSAError(
                f"Could not save view to file -- {m[hresult]} ."
            )
        return hresult

    def save_view_to_file(self, view_name, file_type=file_type_options.JPG):
        """
        Save a single saved graphic view to file.

        :param view_name: the name of view of view list (string)
        :param file_type: the type of file that the views will saved as, from the file_type_options namedtuple (string)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.save_view_to_file")
        expected_file_type = ["WMF", "PNG", "JPG", "TXT", "CSV", "HTM"]
        if file_type.upper() not in (item.upper()
                                     for item in expected_file_type):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_file_type)}. (See namedtuple file_type_options)"
            )
        hresult = self.gsa.SaveViewToFile(view_name, file_type)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "invalid argument"}
            raise GSAError(f"Could not save view to file -- {m[hresult]} .")
        return hresult

    def get_highest_view(self, option=view_options.SGV):
        """
        Find out what the highest numbered saved view is.

        :param option: a setting for specifying the type of view, from the view_options namedtuple (string)
        :return: the highest-numbered preferred or saved Graphic View, Output View or View List (integer)
        """
        self.gsapy_logging("GSA.get_highest_view")
        expected_options = ["PGV", "SGV", "POV", "SOV", "LST"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple view_options)"
            )
        hresult = self.gsa.HighestView(option)
        return hresult

    def view_exist(self, view_ref=1, option=view_options.SGV):
        """
        Does a particular view exist?

        :param option: a setting for specifying the type of view, from the view_options namedtuple (string)
        :param view_ref: the number of the view (integer)
        :return: 1 if the view exists
        """
        self.gsapy_logging("GSA.view_exist")
        expected_options = ["PGV", "SGV", "POV", "SOV", "LST"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple view_options)"
            )
        hresult = self.gsa.ViewExist(option, view_ref)
        return hresult

    def get_view_name(self, view_ref=1, option=view_options.SGV):
        """
        Get the name of a specific saved view.

        :param option: a setting for specifying the type of view, from the view_options namedtuple (string)
        :param view_ref: the number of the view (integer)
        :return: the name of the view (string)
        """
        self.gsapy_logging("GSA.get_view_name")
        expected_options = ["PGV", "SGV", "POV", "SOV", "LST"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple view_options)"
            )
        if self.view_exist(view_ref, option) != 1:
            raise GSAError(f"View {view_ref} does not exist.")
        hresult = self.gsa.ViewName(option, view_ref)
        return hresult

    def get_view_ref(self, view_name, option=view_options.SGV):
        """
        Returns the saved graphic view or output view reference from its name.

        :param option: a setting for specifying the type of view, from the view_options namedtuple (string)
        :param view_name: the name of the save view (integer)
        :return: the reference of the view (integer)
        """
        self.gsapy_logging("GSA.get_view_ref")
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple view_options)"
            )
        hresult = self.gsa.ViewRefFromName(option, view_name)
        if hresult == 0:
            raise GSAError(f"View {view_name} does not exist.")
        return hresult

    def copy_view(self, view_ref=1, option=saved_view_options.SGV):
        """
        Make a copy of a saved view.

        :param option: a setting for specifying the type of saved view, from the saved_view_options namedtuple (string)
        :param view_ref: the number of the view (integer)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.copy_view")
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple view_options)"
            )
        hresult = self.gsa.CopyView(option, view_ref)
        if hresult[1] != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not copy view -- {m[hresult[1]]}.")
        return hresult[0]

    def rename_view(
            self,
            view_ref=1,
            new_name="new_name",
            option=saved_view_options.SGV):
        """
        Rename a saved view.

        :param option: a setting for specifying the type of saved view, from the saved_view_options namedtuple (string)
        :param view_ref: the reference number of the view (integer)
        :param new_name: the new name of the view (string)
        :return: 0 if worked
        """
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple view_options)"
            )
        hresult = self.gsa.RenameView(option, view_ref, str(new_name))
        if hresult != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not copy view -- {m[hresult]}.")
        return hresult

    def create_view(self, view_name):
        '''
        Create new view and set the name.

        :param view_name: the name of the view
        :return: reference index of view
        '''
        self.gsapy_logging("GSA.create_view")
        v = self.gsa.CreateNewView(view_name)
        if not self.view_exist(v):
            raise GSAError(f'Could not create view {view_name}')
        return v

    def delete_view(self, view_ref=1, option=saved_view_options.SGV):
        """
        Delete a saved view by index.

        :param option: a setting for specifying the type of saved view, from the saved_view_options namedtuple (string)
        :param view_ref: the reference number of the view (integer)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.delete_view")
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_options)}. (See namedtuple file_type_options)"
            )
        hresult = self.gsa.DeleteView(option, view_ref)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not copy view -- {m[hresult]}.")
        return hresult

    def rescale_view_data(self, view_ref):
        """
        Rescale a saved view.

        :param view_ref: the reference number of the view, for Graphic Views only (integer)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.rescale_view_data")
        hresult = self.gsa.RescaleViewData(view_ref)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not rescale the view data -- {m[hresult]}.")
        else:
            return hresult

    def get_view_case_list(self, view_ref=1, option=saved_view_options.SGV):
        """
        Find out what cases are associated with a given saved view.

        :param option: a setting for specifying the type of saved view, from the saved_view_options namedtuple (string)
        :param view_ref: the reference number of the view (integer)
        :return: the cases associated with the specified view (list)
        """
        self.gsapy_logging("GSA.get_view_case_list")
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_options)}. (See namedtuple file_type_options)"
            )
        hresult = self.gsa.GetViewCaseList(option, view_ref)
        if hresult[1] != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not get case list of view -- {m[hresult[1]]}.")
        return hresult[0].strip().split(" ")

    def set_view_case_list(
            self,
            view_ref=1,
            case_list="all",
            option=saved_view_options.SGV):
        """
        Change the cases associated with a given saved view.

        :param option: a setting for specifying the type of saved view, from the saved_view_options namedtuple (string)
        :param view_ref: the reference number of the view (integer)
        :param case_list: the new case list for the specified saved view (string)
        :return: 0 if worked
        """
        self.gsapy_logging("GSA.set_view_case_list")
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_options)}. (See namedtuple file_type_options)"
            )
        hresult = self.gsa.SetViewCaseList(option, view_ref, case_list)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not set case list of view -- {m[hresult]}.")
        return hresult

    def get_view_display_list(self, view_ref=1, list_type=EntityEnum.NODE, option=saved_view_options.SGV):
        """
        Find out what entities (e.g. elements) are displayed in a saved view.

        :param option: a setting for specifying the type of saved view, from the saved_view_options namedtuple (string)
        :param view_ref: the reference number of the view (integer)
        :param list_type: the entity type of list (enum value)
        :return: the entity display list (a list description) associated with the specified view (list)
        """
        self.gsapy_logging("GSA.get_view_display_list")
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_options)}. (See namedtuple file_type_options)"
            )
        hresult = self.gsa.GetViewDisplayList(option, int(view_ref), list_type.value)
        if hresult[2] != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not get display list of view -- {m[hresult[1]]}.")
        return hresult[1]

    def set_view_display_list(self, view_ref=1, list_type=EntityEnum.NODE,
                              entity_list="all", option=saved_view_options.SGV):
        """
        Change which entitites (e.g. elements) are displayed in a saved view.

        :param option: a setting for specifying the type of saved view, from the saved_view_options namedtuple (string)
        :param view_ref: the reference number of the view (integer)
        :param list_type: the entity type of list (enum value)
        :return: the list of entities associated with the specified view (list)
        """
        self.gsapy_logging("GSA.set_view_display_list")
        expected_options = ["SGV", "SOV"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_options)}. (See namedtuple file_type_options)"
            )
        hresult = self.gsa.SetViewDisplayList(option, int(view_ref), list_type.value, entity_list)
        if hresult != 0:
            m = {1: "no GSA file open", 2: "view does not exist"}
            raise GSAError(f"Could not set display list of view -- {m[hresult]}.")
        return hresult

    def get_views(self, option=view_options.SGV):
        """
        Get a list of a particular type of views.

        :param option: a setting for specifying the type of view, from the view_options namedtuple (string)
        :return: the reference number and view name for all existing views of the specified view type, None if views of specified view type do not exist (list)
        """
        self.gsapy_logging("GSA.get_views")
        expected_options = ["PGV", "SGV", "POV", "SOV", "LST"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid file type option. Function expects one of: {', '.join(expected_options)}. (See namedtuple file_type_options)"
            )
        highest_from_views = {}
        keys = len(expected_options)
        for i in range(keys):
            highest_from_views[expected_options[i]] = self.get_highest_view(expected_options[i])
        holder = []
        view_list = {}
        for j, k in highest_from_views.items():
            for l in range(1, highest_from_views[j] + 1):
                if self.view_exist(l, j) == 1:
                    p = [l, self.get_view_name(l, j)]
                    holder.append(p)
            view_list[j] = holder
            holder = []
        if view_list[option]:
            return view_list[option]

    def get_view_orientation(self, view_ref = 1):
        """
        Gets the view orientation of the view specified by view_ref

        :param ref:
        :return: the orientation as an list of latitude, longitude, eye_distance, object_point_coordinates, mid_point_coordinates, and picture_rotation
        """
        self.gsapy_logging("GSA.get_view_orientation")
        print('view_ref: ', view_ref)
        hresult, response = self.gsa.GetViewOrientation(view_ref)
        if response != 0:
            if response == 1:
                raise GSAError(f"No file is open.")
            if response == 2:
                raise GSAError(f"View {view_ref} does not exist.")


        return {
            'latitude': hresult.Latitude,
            'longitude': hresult.Longitude,
            'eye_distance': hresult.EyeDistance,
            'object_point_coordinates': [x for x in hresult.ObjectPoint[0]],
            'mid_point_coordinates': [x for x in hresult.MidPoint[0]],
            'picture_rotation': hresult.PictureRotation
        }

    def set_view_orientation(self, view_ref = 1, latitude = None, longitude = None, eye_distance = None, object_point_coordinates = None,
        mid_point_coordinates = None, picture_rotation = None):
        """
        Sets the view orientation of the view specified by view_ref.
        Only parameters which are set are changed.

        Optionally, a dictionary can be passed as a parameter using the ** operator with the keys being the parameter names and the parameters being the values.

        Example: set_view_orientation(\*\*my_dict)
        """
        self.gsapy_logging("GSA.set_view_orientation")
        orientation = defaultdict()

        try:
            orientation = self.get_view_orientation(view_ref)
            log.debug(orientation)
        except GSAError as error:
            raise error

        if latitude is not None:
            if not isinstance(latitude, (int, float)):
                raise GSAError(f"Incorrect latitude type")
            orientation['latitude'] = latitude

        if longitude is not None:
            if not isinstance(longitude, (int, float)):
                raise GSAError(f"Incorrect longitude type")
            orientation['longitude'] = longitude

        if eye_distance is not None:
            if not isinstance(eye_distance, (int, float)):
                raise GSAError(f"Incorrect eye_distance type")
            orientation['eye_distance'] = eye_distance

        if object_point_coordinates is not None:
            if not isinstance(object_point_coordinates, list):
                raise GSAError(f"object_point_coordinates not a list")
            if len(object_point_coordinates) != 3:
                raise GSAError(f"object_point_coordinates must have three items")
            if any(not isinstance(x, (int, float)) for x in object_point_coordinates):
                raise GSAError(f"object_point_coordinates must be a list to numbers")

            orientation['object_point_coordinates'] = object_point_coordinates

        if mid_point_coordinates is not None:
            if not isinstance(mid_point_coordinates, list):
                raise GSAError(f"mid_point_coordinates not a list")
            if len(mid_point_coordinates) != 3:
                raise GSAError(f"mid_point_coordinates must have three items")
            if any(not isinstance(x, (int, float)) for x in mid_point_coordinates):
                raise GSAError(f"mid_point_coordinates must be a list of numbers")

            orientation['mid_point_coordinates'] = mid_point_coordinates

        if picture_rotation is not None:
            if not isinstance(picture_rotation, (int, float)):
                raise GSAError(f"picture_rotation must be a number")
            orientation['picture_rotation'] = picture_rotation

        orientation_object = structs.view_orientation_struct(
            orientation['latitude'],
            orientation['longitude'],
            orientation['eye_distance'],
            orientation['object_point_coordinates'],
            orientation['mid_point_coordinates'],
            orientation['picture_rotation']
        )

        response = self.gsa.SetViewOrientation(view_ref, orientation_object)
        if response != 0:
            if response == 1:
                raise GSAError(f"No file is open.")
            if response == 2:
                raise GSAError(f"View {view_ref} does not exist.")
            if response == 3:
                raise GSAError(f"Incorrect orientation definition.")

    def rescale_view_to_fit(self, view_ref = 1):
        """

        :param view_ref:
        :return:
        """
        self.gsapy_logging("GSA.rescale_view_to_fit")
        response = self.gsa.RescaleViewToFit(view_ref)
        if response != 0:
            if response == 1:
                raise GSAError(f"No file is open.")
            if response == 2:
                raise GSAError(f"View {view_ref} does not exist.")

    def set_view_base_settings(self, view_ref = 1, template = 1):
        """
        Applies `base` view settings from the saved view template provided.

        :param view_ref: reference id of view to be modified (integer)
        :param template: template to be applied. Could be reference id of template (integer) or a GWA command (string)
        """
        self.gsapy_logging("GSA.set_view_base_settings")
        result = ""
        if type(template) is str:
            result = [template]
        else:
            result = self._gwa_command(f"GET,GR_VIEW,{template}")
            if len(result)==0:
                raise GSAError(f"View {template} does not exist.")

        #TODO: Throws 'Not Implemented' error
        result = self.gsa.SetViewBaseSettings(view_ref,"\t".join(result[0]))

        if result != 0:
            if result == 1:
                raise GSAError(f"No file is open.")
            if result == 2:
                raise GSAError(f"View {view_ref} does not exist.")
            if result == 3:
                raise GSAError(f"Empty or invalid GWA template string.")
            if result == 4:
                raise GSAError(f"Unable to read valid view from GWA template string.")

    def set_view_contour(self, view_ref = 1, dataref = dr.REF_DISP_DZ, template = None):
        """
        Applies the contour settings from the saved view template provided onto a given saved view
        referenced by id. Then sets the output component that is contoured to `dataref`.

        :param view_ref: reference id of view to be modified (integer)
        :param dataref: data reference code refering to data to be displayed
        :param template: template to be applied. Could be reference id of template (integer) or a GWA command (string)
        """
        self.gsapy_logging("GSA.set_view_contour")
        result = []
        if type(template) is str:
            result = [template]
        elif template is None:
            result = ['GR_VIEW.18,101450690,127,CONTOUR_TEMPLATE,0,0,0,0,1,1,' +
                '4,2,-46,1,1,1,-4,2,1,-4,3,1,-4,8,1,-4,2,' +
                '0,' +
                '0.000000000000,90.0000000000,200.000000000,0.000000000000,20.0000000000,12.0000000000,2.00000000000,0.000000000000,0.000000000000,0.000000000000,0.000000000000,0.000000000000,0.000000000000,0.0197395000000,1,0.000000000000,0.000000000000,1.00000000000,0,0.000000000000,1.00000000000,0,1.00000000000,30.0000000000,2,0.000000000000,0.000000000000,1000000.00000,WHITE,RGB(0x606060),0,1.00000000000,1.00000000000,1.00000000000,2,1,-5,3,1,-5,' +
                '0,0,1.00000000000,0.000000000000,0.000000000000,0.000000000000,0.000000000000,0.000000000000,0.000000000000,1.00000000000,1.00000000000,1.00000000000,1.00000000000,3.00000000000,1.20000000000,55.0000000000,3,2,0,1,' +
                '2,' +
                '25235641,25,0,0,0,0,0,0,0,1,0,1,2,2,1,1,1,7,0,0,2,0,3,1,0,1,0,2,0,3,0,6,0,7,0,8,0,1,0,2,0,3,0,6,0,7,0,8,0,0,1,-4,0,1,-4,' +
                '0,0,GLOBAL,0.000000000000,0,-<I>,<I>,' +
                '0,' +
                'kN,6.95185e-310,m,7.e-310,kg,7.e-310,s,7.e-310,°C,7.e-310,mm,7.e-310,Pa,7.e-310,m/s²,7.e-310,m,7.e-310,' +
                '1,4,2,4,1.61895e-319,' +
                '1.00000000000,-<I>,<I>,8,' +
                '0,' +
                '<I>,3,0,2,1,' +
                '25235460,17,0,0,0,0,0,0,0,1,0,1,2,2,1,1,1,7,0,0,2,0,3,1,0,1,0,2,0,3,0,6,0,7,0,8,0,1,0,2,0,3,0,6,0,7,0,8,0,0,1,-4,0,1,-4,' +
                '14002006,6,GLOBAL,0.000500000000000,1,-0.000231496000197,-0.000110315086204,' +
                '0,' +
                'kN,6.95185e-310,m,7.e-310,kg,7.e-310,s,7.e-310,°C,7.e-310,mm,7.e-310,Pa,7.e-310,m/s²,7.e-310,m,7.e-310,' +
                '1,4,2,4,1.61895e-319,' +
                '1.00000000000,-<I>,<I>,8,' +
                '0,' +
                '<I>,3,0,2,1']

            result[0] = result[0].split(',')
        else:
            result = self._gwa_command(f"GET,GR_VIEW,{template}")
            if len(result)==0:
                raise GSAError(f"View {template} does not exist.")

        result = self.gsa.SetViewContour(view_ref,dataref,"\t".join(result[0]))

        if result != 0:
            if result == 1:
                raise GSAError(f"No file is open.")
            if result == 2:
                raise GSAError(f"View {view_ref} does not exist.")
            if result == 3:
                raise GSAError(f"Empty or invalid GWA template string.")
            if result == 4:
                raise GSAError(f"Unable to read valid view from GWA template string.")

    def set_view_labels(self, view_ref = 1, template = 1):
        """
        Applies labels settings from the supplied view template onto the saved view with the given reference.

        :param view_ref: reference id of view to be modified (integer)
        :param template: template to be applied. Could be reference id of template (integer) or a GWA command (string)
        """
        self.gsapy_logging("GSA.set_view_labels")
        result = ""
        if type(template) is str:
            result = [template]
        else:
            result = self._gwa_command(f"GET,GR_VIEW,{template}")
            if len(result)==0:
                raise GSAError(f"View {template} does not exist.")

        # TODO: Does not work
        result = self.gsa.SetViewLabels(view_ref, "\t".join(result[0]))

        if result != 0:
            if result == 1:
                raise GSAError(f"No file is open.")
            if result == 2:
                raise GSAError(f"View {view_ref} does not exist.")
            if result == 3:
                raise GSAError(f"Empty or invalid GWA template string.")
            if result == 4:
                raise GSAError(f"Unable to read valid view from GWA template string.")

    def set_view_diagram(self, view_ref = 1, dataref = dr.REF_DISP_DZ, template = None):
        """
        Applies the diagram ettings from the saved view template provided onto a given saved view
        referenced by id. Then draws the diagram for the output component represented by ‘dataref’.

        :param view_ref: reference id of view to be modified (integer)
        :param dataref: data reference code refering to data to be displayed
        :param template: template to be applied. Could be reference id of template (integer) or a GWA command (string)
        """
        self.gsapy_logging("GSA.set_view_diagram")
        result = ""
        if type(template) is str:
            result = [template]
        elif template is None:
            result = ['GR_VIEW.18,101450690,127,DIAGRAM_TEMPLATE,0,0,0,0,1,1,4,2,-46,1,1,1,-4,2,1,'+
                '-4,3,1,-4,8,1,-4,2,0,-47.3800000000,20.6700000000,200.000000000,0.000000000000,'+
                '20.0000000000,12.0000000000,2.00000000000,0.000000000000,0.000000000000,0.000000000000'+
                ',0.000000000000,0.000000000000,0.000000000000,0.0197395000000,1,0.000000000000,'+
                '0.000000000000,1.00000000000,0,0.000000000000,1.00000000000,0,1.00000000000,30.0000000000'+
                ',2,0.000000000000,0.000000000000,1000000.00000,WHITE,RGB(0x606060),0,1.00000000000,'+
                '1.00000000000,1.00000000000,2,1,-5,3,1,-5,0,0,1.00000000000,0.000000000000,0.000000000000,'+
                '0.000000000000,0.000000000000,0.000000000000,0.000000000000,1.00000000000,1.00000000000,'+
                '1.00000000000,1.00000000000,3.00000000000,1.20000000000,55.0000000000,3,2,0,1,2,25235641,'+
                '25,0,0,0,0,0,0,0,1,0,1,2,2,1,1,1,7,0,0,2,0,3,1,0,1,0,2,0,3,0,6,0,7,0,8,0,1,0,2,0,3,0,6,0,'+
                '7,0,8,0,0,1,-4,0,1,-4,0,0,GLOBAL,0.000000000000,0,-<I>,<I>,0,kN,6.95185e-310,m,7.e-310,'+
                'kg,7.e-310,s,7.e-310,°C,7.e-310,mm,7.e-310,Pa,7.e-310,m/s²,7.e-310,m,7.e-310,1,4,2,4,'+
                '1.61895e-319,1.00000000000,-<I>,<I>,8,0,<I>,3,0,2,1,25235458,17,0,0,0,0,0,0,0,1,0,1,2,2'+
                ',1,1,1,7,0,0,2,0,3,1,0,1,0,2,0,3,0,6,0,7,0,8,0,1,0,2,0,3,0,6,0,7,0,8,0,0,1,-4,0,1,-4,'+
                '14002006,112,LOCAL,50000.0000000,1,-26363.5781250,50876.9062500,0,kN,6.95185e-310,m,'+
                '7.e-310,kg,7.e-310,s,7.e-310,°C,7.e-310,mm,7.e-310,Pa,7.e-310,m/s²,7.e-310,m,7.e-310,1,'+
                '4,2,4,1.61895e-319,1.00000000000,-<I>,<I>,8,0,<I>,3,0,2,1']

            result[0] = result[0].split(',')
        else:
            result = self._gwa_command(f"GET,GR_VIEW,{template}")
            if len(result)==0:
                raise GSAError(f"View {template} does not exist.")

        # TODO: This function sets contour instead of diagram
        result = self.gsa.SetViewDiagram(view_ref,dataref,"\t".join(result[0]))

        if result != 0:
            if result == 1:
                raise GSAError(f"No file is open.")
            if result == 2:
                raise GSAError(f"View {view_ref} does not exist.")
            if result == 3:
                raise GSAError(f"Empty or invalid GWA template string.")
            if result == 4:
                raise GSAError(f"Unable to read valid view from GWA template string.")

    # List Functions
    def _get_entities_in_list_description(self, gsa_list="all", entity_type=EntityEnum.NODE):
        """
        Get entity indices based on a list description. Do not use this function directly.

        :param gsa_list: a list description using GSA list syntax (string)
        :param entity_type: the entity type of list (integer)
        :return: a list of the entities included in the given list description (string)
        """
        if isinstance(gsa_list, int):
            gsa_list = str(gsa_list)
        try:
            hresult = self.gsa.EntitiesInList(gsa_list, entity_type.value)
        except IndexError:
            raise GSAError(f"List {gsa_list} either: 1) does not exist, 2) is badly formatted, or 3) is empty.")
        if isinstance(hresult, int):
            if hresult == 3: # GSA error code for empty list
                return []
            m = {1: "No GSA file is open",
                 2: "saved list does not exist", 3: "no items in list"}
            raise GSAError(f"Could not get entities -- {m[hresult]}")

        return sorted(hresult[1])

    def _get_entities_in_numbered_list(self, list_num):
        """
        Get entity indices based on a list number. Do not use this function directly.

        :param list_num: the reference number of a saved list (integer)
        :return: a list of the entities included in the specified saved list (string)
        """

        try:
            hresult = self.gsa.EntitiesInList(str(list_num))
        except IndexError:
            raise GSAError(f"List {list_num} either: 1) does not exist, 2) is badly formatted, or 3) is empty.")
        if isinstance(hresult, int):
            m = {1: "No GSA file is open",
                 2: "saved list does not exist", 3: "no items in list"}
            raise GSAError(f"Could not get entities -- {m[hresult]}")

        return sorted(hresult[1])

    # TODO: can we get this to work with the underlying API function now that comtypes 1.1.4 fixed the bug we found?
    def _get_entities_in_named_list(self, list_name):
        """
        Get entity indices based on a list name. Do not use this function directly.

        :param list_name: the name of a saved list (string)
        :return: a list of the entities included in the specified saved list(string)
        """
        saved_lists = self.get_all_saved_lists()

        for gsa_list in saved_lists:
            if gsa_list.name == list_name:
                return self._get_entities_in_numbered_list(gsa_list.index)

        raise GSAError(f"Could not get entities for list named {list_name}.")

    def get_all_saved_lists(self):
        """
        Get the definitions of all saved lists.

        :return: a python list of python lists defining of all GSA saved lists.
            [list reference number, name, type, description] (list of lists)
        """
        self.gsapy_logging("GSA.get_all_saved_lists")
        gwa_lists = self.gsa.GwaCommand("GET_ALL, LIST")
        if gwa_lists == "":
            raise GSAError("Could not retrieve saved lists.")
        return [GSAList.from_gwa(s.split(",")) for s in gwa_lists.splitlines()]

    def is_item_included_in_list_description(self, ref, option=list_options.ITEM, list_desc="all"):
        """
        Check if an item is included in a list description.

        :param ref: the reference number of the item to be checked for inclusion (integer)
        :param option: a setting for specifying the type of list, from the list_options namedtuple (string)
        :param list_desc: a list description using GSA list syntax (string)
        :return: 1 if the item is included in the list
        """
        self.gsapy_logging("GSA.is_item_included_in_list_description")
        expected_options = ["ITEM", "NODE", "ELEM", "MEMBER", "CASE_ANAL", "CASE_COMB", "GRID_PT"]
        if option.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple list_options)"
            )
        result = self.gsa.IsItemIncluded(option, int(ref), list_desc)
        return bool(result)

    # Case and Task Functions
    def highest_case(self, case_type=case_type_options.L):
        """
        check what the highest number of a particular type of case is.

        :param case_type: a setting for specifying the type of case, from the case_type_options namedtuple (string)
        :return: the highest-numbered case of the specified type (integer)
        """
        self.gsapy_logging("GSA.highest_case")
        expected_options = ["L", "A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )

        result = self.gsa.HighestCase(case_type)
        return result

    def case_exist(self, case_type=case_type_options.L, case_ref=1):
        """
        Does a particular case exist?

        :param case_type: a setting for specifying the type of case, from the case_type_options namedtuple (string)
        :param case_ref: the case number (integer)
        :return: 1 if the case exists
        """
        self.gsapy_logging("GSA.case_exist")
        expected_options = ["L", "A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )

        result = self.gsa.CaseExist(case_type, int(case_ref))
        return result


    def case_name(self, case_type=case_type_options.L, case_ref=1):
        """
        What is the name of a given case?

        :param case_type: a setting for specifying the type of case, from the case_type_options namedtuple (string)
        :param case_ref: the case number (integer)
        :return: the name of the case (string)
        """
        self.gsapy_logging("GSA.case_name")
        expected_options = ["L", "A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )

        if self.gsa.CaseExist(case_type, int(case_ref)) != 1:
            raise GSAError(f"Case {case_ref} does not exist.")

        result = self.gsa.CaseName(case_type, int(case_ref))
        return result


    def case_num_perm(self, case_type=case_perm_type_options.A, case_ref=1):
        """
        How many permutations does a case have?

        :param case_type: a setting for specifying the type of case, from the case_perm_type_options namedtuple (string)
        :param case_ref: the case number (integer)

        :return: the number of permutations for the case (integer), 0 if the case is not an enveloping case
        """
        self.gsapy_logging("GSA.case_num_perm")
        expected_options = ["A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )

        if self.gsa.CaseExist(case_type, int(case_ref)) != 1:
            raise GSAError(f"Case {case_ref} does not exist.")

        result = self.gsa.CaseNumPerm(case_type, int(case_ref))
        return result


    def case_perm_desc(self, case_type=case_perm_type_options.A, case_ref=1, perm_num=0):
        """
        Create the case description string.

        :param case_type: a setting for specifying the type of case, from the case_perm_type_options namedtuple (string)
        :param case_ref: the case number (integer)
        :param perm_num: the permutation number to refer to a permutation or 0 to refer to the specified case (integer)

        :return: the case description of the specified case (string)
        """
        self.gsapy_logging("GSA.case_perm_desc")
        expected_options = ["A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )

        if self.gsa.CaseExist(case_type, int(case_ref)) != 1:
            raise GSAError(f"Case {case_ref} does not exist.")

        if self.gsa.CaseNumPerm(case_type, int(case_ref)) < perm_num:
            raise GSAError(f"Case {case_ref} does not have the specified permutation number")

        result = self.gsa.CasePermDesc(case_type, int(case_ref), int(perm_num))
        return result


    def case_perm_string(self, case_type=case_type_options.L, case_ref=1, perm_num=0):
        """
        Create a properly formatted case/permutation string.

        :param case_type: a setting for specifying the type of case, from the case_type_options namedtuple (string)
        :param case_ref: the case number (integer)
        :param perm_num: the permutation number to refer to a permutation of the case or 0 to refer to the specified case (integer)

        :return: the case reference (string)
        """
        self.gsapy_logging("GSA.case_perm_string")
        expected_options = ["L", "A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )


        result = self.gsa.CasePermString(case_type, int(case_ref), int(perm_num))
        return result


    def parse_case_string(self, case_string: str):
        """
        Parse a case description into it's constituent parts

        :param: case_string: a GSA-formatted case string (e.g. L1, A2p3, C1min, etc...)
        :return: tuple of the type (L, A, or C), number and permutation
        """
        self.gsapy_logging("GSA.parse_case_string")
        match = fullmatch("([LAC])(\d+)(p\d+|max|abs|signabs|min)?",case_string)

        if match is None:
            raise GSAError(f"{case_string} is not a valid case string.")

        groups = match.groups(default=0)

        try:
            if fullmatch("p\d*",groups[2]):
                return groups[0], int(groups[1]), int(groups[2][1:])
        except TypeError:
            pass

        return groups[0], int(groups[1]), groups[2]


    def case_perm_anal_factor(self, case_type=case_perm_type_options.A, case_ref=1, perm_num=0, anal_ref=1):
        """
        Find out what the factor on a given analysis case is in a given combination case.

        :param case_type: a setting for specifying the type of case, from the case_perm_type_options namedtuple (string)
        :param case_ref: the case number (integer)
        :param perm_num: the permutation number to refer to a permutation of the case or 0 to refer to the specified case (integer)
        :param anal_ref: the analysis case number (integer)

        :return: the factor on the specified analysis case for the given case reference, ex. 1.2 returned for A1 for a case with a case description of 1.2A1 + 1.6A2 (float)
        """
        self.gsapy_logging("GSA.case_perm_anal_factor")
        expected_options = ["A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )

        if self.gsa.CaseExist(case_type, int(case_ref)) != 1:
            raise GSAError(f"Case {case_type}{case_ref}p{perm_num} does not exist.")

        result = self.gsa.CasePermAnalFactor(case_type, int(case_ref), int(perm_num), int(anal_ref))
        return result


    def case_results_exist(self, case_type=case_perm_type_options.A, case_ref=1, perm_num=0):
        """
        Do results exist for a given analysis case?

        :param case_type: a setting for specifying the type of case, from the case_perm_type_options namedtuple (string)
        :param case_ref: the case number (integer)
        :param perm_num: the permutation number to refer to a permutation of the case or 0 to refer to the specified case (integer)

        :return: 1 if the results exist
        """
        self.gsapy_logging("GSA.case_results_exist")
        expected_options = ["A", "C"]
        if case_type.upper() not in (item.upper() for item in expected_options):
            raise ValueError(
                f"Invalid option. Function expects one of: {', '.join(expected_options)}. (See namedtuple case_type_options)"
            )

        if self.gsa.CaseExist(case_type, int(case_ref)) != 1:
            raise GSAError(f"Case {case_type}{case_ref} does not exist.")

        if self.gsa.CaseNumPerm(case_type, int(case_ref)) < perm_num:
            raise GSAError(f"Case {case_type}{case_ref} does not have the specified permutation number")

        result = self.gsa.CaseResultsExist(case_type, int(case_ref), int(perm_num))
        return result


    def case_task(self, case_ref):
        """
        What is the analysis task number of a given case?

        :param case_ref: the analysis case number (integer)

        :return: the reference number of the analysis task that is parent to the specified analysis case (integer)
        """
        self.gsapy_logging("GSA.case_task")
        if self.gsa.CaseExist(case_type_options.A, int(case_ref)) != 1:
            raise GSAError(f"Case {case_ref} does not exist.")

        result = self.gsa.CaseTask(int(case_ref))
        return result


    def task_status(self, case_ref):
        """
        What is the status of a given analysis task?

        :param case_ref: the analysis case number (integer)

        :return: 0 if the task exists and has been analysed, 1 if no GSA file is open, 2 if task does not exist or 3 if task exists but has not been analysed (integer)
        """
        self.gsapy_logging("GSA.task_status")
        result = self.gsa.TaskStatus(int(case_ref))
        return result


    def design_task_status(self, case_ref):
        """
        What is the status of a design task
        
        :param case_ref: design task reference number
        :return: 1 if no file open, 2 if design task does not exist, 3 if design task has results, 4. if design task has not been designed or checked
        """
        self.gsapy_logging("GSA.design_task_status")
        result = self.gsa.DesignTaskStatus(int(case_ref))
        return result
